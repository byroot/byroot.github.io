<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>What‚Äôs wrong with the JSON gem API? | byroot‚Äôs blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="What‚Äôs wrong with the JSON gem API?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As I mentioned at the start of my Optimizing Ruby‚Äôs JSON series of posts, performance isn‚Äôt why I candidated to be the new gem‚Äôs maintainer." />
<meta property="og:description" content="As I mentioned at the start of my Optimizing Ruby‚Äôs JSON series of posts, performance isn‚Äôt why I candidated to be the new gem‚Äôs maintainer." />
<link rel="canonical" href="https://byroot.github.io/ruby/json/2025/08/02/whats-wrong-with-the-json-gem-api.html" />
<meta property="og:url" content="https://byroot.github.io/ruby/json/2025/08/02/whats-wrong-with-the-json-gem-api.html" />
<meta property="og:site_name" content="byroot‚Äôs blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-08-02T09:03:51+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="What‚Äôs wrong with the JSON gem API?" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-08-02T09:03:51+00:00","datePublished":"2025-08-02T09:03:51+00:00","description":"As I mentioned at the start of my Optimizing Ruby‚Äôs JSON series of posts, performance isn‚Äôt why I candidated to be the new gem‚Äôs maintainer.","headline":"What‚Äôs wrong with the JSON gem API?","mainEntityOfPage":{"@type":"WebPage","@id":"https://byroot.github.io/ruby/json/2025/08/02/whats-wrong-with-the-json-gem-api.html"},"url":"https://byroot.github.io/ruby/json/2025/08/02/whats-wrong-with-the-json-gem-api.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png"><link type="application/atom+xml" rel="alternate" href="https://byroot.github.io/feed.xml" title="byroot&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">byroot&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">What&#39;s wrong with the JSON gem API?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-08-02T09:03:51+00:00" itemprop="datePublished">Aug 2, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>As I mentioned at the start of my <a href="/ruby/json/2024/12/15/optimizing-ruby-json-part-1.html">Optimizing Ruby‚Äôs JSON</a> series of posts,
performance isn‚Äôt why I candidated to be the new gem‚Äôs maintainer.</p>

<p>The actual reason is that the gem has many APIs that I think aren‚Äôt very good, and some that are outright dangerous.</p>

<p>As a gem user, it‚Äôs easy to be annoyed at deprecations and breaking changes.
It‚Äôs noisy and creates extra work, so I entirely understand that people may suffer from deprecation fatigue.
But while it occasionally happens to run into mostly cosmetic deprecations that aren‚Äôt really worth the churn they cause (and that annoys me a lot too),
most of the time there‚Äôs a good reason for them, it just is very rarely conveyed to the users, and even more rarely discussed,
so let‚Äôs do that for once.</p>

<p>So I‚Äôd like to go over some of the API changes and deprecations I already implemented or will likely implement soon,
given it‚Äôs a good occasion to explain why the change is valuable, and to talk about API design more broadly.</p>

<h2 id="dealing-with-deprecations-in-ruby">Dealing With Deprecations in Ruby</h2>

<p>But before I delve into deprecated API, I‚Äôd like to mention how to effectively deal with deprecations in modern Ruby.</p>

<p>Since Ruby 2.7, warning messages emitted with <code class="language-plaintext highlighter-rouge">Kernel#warn</code> are categorized, and one of the available categories is <code class="language-plaintext highlighter-rouge">:deprecated</code>.
By default, deprecation warnings are silenced; to display them, you must enable the <code class="language-plaintext highlighter-rouge">:deprecated</code> category like so:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Warning</span><span class="p">[</span><span class="ss">:deprecated</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre></div></div>

<p>It is very highly recommended to do so in your test suite, so much so that Rails and Minitest will do it by default.</p>

<p>However, if you are using RSpec, you‚Äôll have to do it yourself in your <code class="language-plaintext highlighter-rouge">spec_helper.rb</code> file, because we‚Äôve tried to get
<a href="https://github.com/rspec/rspec/issues/37">RSpec to do it too for over four years now, but without success</a>.
But I‚Äôm still hopeful <a href="https://github.com/rspec/rspec/pull/161">it will eventually happen</a>.</p>

<p>Another useful thing to know about Ruby‚Äôs <code class="language-plaintext highlighter-rouge">Kernel#warn</code> method is that under the hood, it calls the <code class="language-plaintext highlighter-rouge">Warning.warn</code> method,
allowing you to redefine it and customize its behavior.</p>

<p>For instance, you could turn warnings into errors like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Warning</span>
  <span class="k">def</span> <span class="nf">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">message</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Doing so both ensures warnings aren‚Äôt missed, and helps tracking them down as you‚Äôll get an exception with a full backtrace
rather than a warning that points at a single call-site that may not necessarily help you find the problem.</p>

<p>This is a pattern I use in most of my own projects, and that <a href="https://github.com/rails/rails/blob/add5a73b26e78d6b13945525874749ae40af21c7/tools/strict_warnings.rb">I also included into Rails‚Äô own test suite</a>.
For larger projects, where being deprecation-free all the time may be complicated, there‚Äôs also the more sophisticated [<code class="language-plaintext highlighter-rouge">deprecation_toolkit</code> gem].</p>

<h2 id="the-create_additions-option">The create_additions Option</h2>

<p>Now, let‚Äôs start with the API that convinced me to request maintainership.</p>

<p>Do you know the difference between <code class="language-plaintext highlighter-rouge">JSON.load</code> and <code class="language-plaintext highlighter-rouge">JSON.parse</code>?</p>

<p>There‚Äôs more than one, but the main difference is that it has a different set of options enabled by default, and notably
one that is a massive footgun: <code class="language-plaintext highlighter-rouge">create_additions: true</code>.</p>

<p>This option is so bad that <a href="https://github.com/rubocop/rubocop/pull/3448">Rubocop‚Äôs default set of rules bans <code class="language-plaintext highlighter-rouge">JSON.load</code> outright for security reasons</a>,
and it has been involved in more than one <a href="https://discuss.rubyonrails.org/t/cve-2023-27531-possible-deserialization-of-untrusted-data-vulnerability-in-kredis-json/82467">security vulnerabilities</a>.</p>

<p>Let‚Äôs dig into what it does:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"json"</span>

<span class="k">class</span> <span class="nc">Point</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">json_create</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">new</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">"x"</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">"y"</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="vi">@x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="vi">@y</span> <span class="o">=</span> <span class="n">y</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">document</span> <span class="o">=</span> <span class="o">&lt;&lt;~</span><span class="no">'JSON'</span><span class="sh">
  {
    "json_class": "Point",
    "x": 123.456,
    "y": 789.321
  }
</span><span class="no">JSON</span>

<span class="nb">p</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>
<span class="c1"># =&gt; {"json_class" =&gt; "Point", "x" =&gt; 123.456, "y" =&gt; 789.321}</span>

<span class="nb">p</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;Point:0x00000001007f6d08 @x=123.456, @y=789.321&gt;</span>
</code></pre></div></div>

<p>So what the <code class="language-plaintext highlighter-rouge">create_additions: true</code> parsing option does is that when it notices an object with the special key <code class="language-plaintext highlighter-rouge">"json_class"</code>,
It resolves the constant and calls <code class="language-plaintext highlighter-rouge">#json_create</code> on it with the object.</p>

<p>By itself, this isn‚Äôt really a security vulnerability, as only classes with a <code class="language-plaintext highlighter-rouge">.json_create</code> method can be instantiated this way.
But if you‚Äôve been using Ruby for a long time, this may remind you of similar issues with gems like <code class="language-plaintext highlighter-rouge">YAML</code> where similar capabilities
were exploited.</p>

<p>That‚Äôs the problem with these sorts of duck-typed APIs: they are way too global.</p>

<p>You can have a piece of code using <code class="language-plaintext highlighter-rouge">JSON.load</code> that is perfectly safe on its own, but then if it‚Äôs embedded in an application
that also loads some other piece of code that defines some <code class="language-plaintext highlighter-rouge">.json_create</code> methods you weren‚Äôt expecting, you may end up with
an unforeseen vulnerability.</p>

<p>But even if you don‚Äôt define any <code class="language-plaintext highlighter-rouge">json_create</code> methods, the gem will always define one on <code class="language-plaintext highlighter-rouge">String</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="nb">require</span> <span class="s2">"json"</span>
<span class="o">&gt;&gt;</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s1">'{"json_class": "String", "raw": [112, 119, 110, 101, 100]}'</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"pwned"</span>
</code></pre></div></div>

<p>Here again, you probably need to find some specific circumstances to exploit that, but you can probably see how this
trick can be used to bypass a validation check of some sort.</p>

<p>So what do I plan to do about it? Several things.</p>

<p>First, I deprecated the implicit <code class="language-plaintext highlighter-rouge">create_additions: true</code> option. If you use <code class="language-plaintext highlighter-rouge">JSON.load</code> for that feature, a deprecation
warning will be emitted, asking to use <code class="language-plaintext highlighter-rouge">JSON.unsafe_load</code> instead:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"json"</span>
<span class="no">Warning</span><span class="p">[</span><span class="ss">:deprecated</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
<span class="no">JSON</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s1">'{"json_class": "String", "raw": [112, 119, 110, 101, 100]}'</span><span class="p">)</span>
<span class="c1"># /tmp/j.rb:3: warning: JSON.load implicit support for `create_additions: true`</span>
<span class="c1"># is deprecated and will be removed in 3.0,</span>
<span class="c1"># use JSON.unsafe_load or explicitly pass `create_additions: true`</span>
</code></pre></div></div>

<p>That being said, considering how wonky this feature is, I‚Äôm also considering extracting it into another gem.</p>

<p>This used to be impossible, as it was baked deep into the both the C and the Java parsers,
but <a href="https://github.com/ruby/json/pull/774">I recently refactored it to be pure Ruby code using a callback exposed by the parsers</a>.</p>

<p>Now you can provide a <code class="language-plaintext highlighter-rouge">Proc</code> to <code class="language-plaintext highlighter-rouge">JSON.load</code>, the parser will invoke it for every parsed value, allowing you to substitute
a value by another:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cb</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">case</span> <span class="n">obj</span>
  <span class="k">when</span> <span class="no">String</span>
    <span class="n">obj</span><span class="p">.</span><span class="nf">upcase</span>
  <span class="k">else</span>
    <span class="n">obj</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s1">'["a", {"b": 1}]'</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span>
<span class="c1"># =&gt; ["A", {"B" =&gt; 1}]</span>
</code></pre></div></div>

<p>Prior to that change, <code class="language-plaintext highlighter-rouge">JSON.load</code> already accepted a Proc, but its return value was ignored.</p>

<p>The nice thing is that this callback also now serves as a much safer and flexible way to handle the serialization of rich objects.
For instance, you could implement something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">types</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">"range"</span> <span class="o">=&gt;</span> <span class="no">MyRangeType</span>
<span class="p">}</span>
<span class="n">cb</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">case</span> <span class="n">obj</span>
  <span class="k">when</span> <span class="no">Hash</span>
    <span class="k">if</span> <span class="n">type</span> <span class="o">=</span> <span class="n">types</span><span class="p">[</span><span class="n">obj</span><span class="p">[</span><span class="s2">"__type"</span><span class="p">]]</span>
      <span class="n">type</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">obj</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">obj</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">p</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s1">'["a", {"b": 1}]'</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span>
<span class="c1"># =&gt; ["A", {"B" =&gt; 1}]</span>
</code></pre></div></div>

<p>While this requires more code from the user, it gives much tighter control over the deserialization,
but more importantly, it isn‚Äôt global anymore.
If a library uses this feature to deserialize trusted data, its callback is never going to be invoked by another library
like it‚Äôs the case with the old <code class="language-plaintext highlighter-rouge">Class#json_create</code> API.</p>

<p>The obvious solution would have been to follow the same route as <code class="language-plaintext highlighter-rouge">YAML</code>, with its <code class="language-plaintext highlighter-rouge">permitted_classes</code> argument, but
in my opinion, it wouldn‚Äôt have addressed the root of the problem, and it makes for a very unpleasant API to use.</p>

<p>Instead, I believe this Proc interface provides the same functionality as before, but in a way that is both more
flexible and safer.</p>

<p>I think this is a clear case for deprecation, given it is very rarely needed, has security implications, and surprises users.</p>

<h2 id="parsing-of-duplicate-keys">Parsing of Duplicate Keys</h2>

<p>Another behavior of the parser I recently deprecated is the treatment of duplicate keys.
Consider the following code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="s1">'{"a": 1, "a": 2}'</span><span class="p">)[</span><span class="s2">"a"</span><span class="p">]</span>
</code></pre></div></div>

<p>What do you think it should return? You could argue that the first key or the last key should win, or that this should
result in a parse error.</p>

<p>Unfortunately, JSON is a bit of a ‚Äúpost-specified‚Äù format, as in it started as <a href="https://www.json.org/json-en.html">an extremely simple document</a>.
All it says about ‚Äúobjects‚Äù is:</p>

<blockquote>
  <p>An object is an unordered set of name/value pairs.
An object begins with <code class="language-plaintext highlighter-rouge">{</code> and ends with <code class="language-plaintext highlighter-rouge">}</code>.
Each name is followed by <code class="language-plaintext highlighter-rouge">:</code> and the name/value pairs are separated by <code class="language-plaintext highlighter-rouge">,</code>.</p>
</blockquote>

<p>That‚Äôs it, that‚Äôs the extent of the specification, as you can see, there is no mention of what a parser should do if it encounters a duplicate key.</p>

<p>Later on, various standardisation bodies tried to specify JSON based on the implementations out there.</p>

<p>Hence, we now have IETF‚Äôs STD 90, also known as <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259</a>, which states:</p>

<blockquote>
  <p>Many implementations report the last name/value pair only.
Other implementations report an error or fail to parse the object,
and some implementations report all of the name/value pairs, including duplicates.</p>
</blockquote>

<p>In other words, it acknowledges most implementations return the last seen pair, but doesn‚Äôt prescribe any particular behavior.</p>

<p>There‚Äôs also the <a href="https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf">ECMA-404 standard</a></p>

<blockquote>
  <p>The JSON syntax does not impose any restrictions on the strings used as names,
does not require that name strings be unique, and does not assign any significance to the ordering of name/value pairs.
These are all semantic considerations that may be defined by
JSON processors or in specifications defining specific uses of JSON for data interchange.</p>
</blockquote>

<p>Which is pretty much the specification language equivalent of: ü§∑‚Äç‚ôÇÔ∏è.</p>

<p>The problem with under-specified formats is that they can sometimes be exploited, the classic example being
<a href="https://en.wikipedia.org/wiki/HTTP_request_smuggling">HTTP request smuggling</a>.</p>

<p>And while it wasn‚Äôt an exploitation per se, <a href="https://hackerone.com/reports/3000510#activity-32819479">a security issue happened to Hacker One</a>,
in part because of that behavior.
Technically, the bug was on the JSON generation side, but if the JSON‚Äôs gem parser didn‚Äôt silently accept duplicated keys,
they would have caught it early in development.</p>

<p>That‚Äôs why starting from version <code class="language-plaintext highlighter-rouge">2.13.0</code>, <code class="language-plaintext highlighter-rouge">JSON.parse</code> <a href="https://github.com/ruby/json/pull/818">now accepts a new <code class="language-plaintext highlighter-rouge">allow_duplicate_key:</code> keyword argument</a>,
and if not explicitly allowed, a deprecation warning is emitted if a duplicate key is encountered:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"json"</span>
<span class="no">Warning</span><span class="p">[</span><span class="ss">:deprecated</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>

<span class="nb">p</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="s1">'{"a": 1, "a": 2}'</span><span class="p">)</span>
<span class="c1"># =&gt; {"a" =&gt; 2}</span>

<span class="c1"># /tmp/j.rb:4: warning: detected duplicate key "a" in JSON object.</span>
<span class="c1"># This will raise an error in json 3.0 unless enabled via `allow_duplicate_key: true`</span>
<span class="c1">#at line 1 column 1</span>
</code></pre></div></div>

<p>As mentioned in the warning message, I plan to change the default behavior to be an error in the next major version, but of course
it will always be possible to explicitly allow for duplicate keys, for the rare cases where it‚Äôs needed.</p>

<p>Here again, I think this deprecation is justified because duplicated keys are rare, but also almost always a mistake,
hence I expect few people to need to change anything, and the ones who do will likely learn about a previously unnoticed
mistake in their application.</p>

<h2 id="the-to_json-and-to_s-methods">The to_json And to_s Methods</h2>

<p>Before you gasp in horror, don‚Äôt worry, I don‚Äôt plan on deprecating the <code class="language-plaintext highlighter-rouge">Object#to_json</code> method, ever.
It is way too widespread for this to ever be acceptable.</p>

<p>But that doesn‚Äôt mean this API is good, nor that nothing should be done about it.</p>

<p>At the center of the <code class="language-plaintext highlighter-rouge">json</code> gem API, there‚Äôs the notion that objects can define themselves how they should be
serialized into JSON by responding to the <code class="language-plaintext highlighter-rouge">to_json</code> method.</p>

<p>At first sight, it seems like a perfectly fine API, it‚Äôs an interface that objects can implement, fairly classic object-oriented design.</p>

<p>Here‚Äôs an example that changes how <code class="language-plaintext highlighter-rouge">Time</code> objects are serialized.</p>

<p>By default, <code class="language-plaintext highlighter-rouge">json</code> will call <code class="language-plaintext highlighter-rouge">#to_s</code> on objects it doesn‚Äôt know how to handle:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">generate</span><span class="p">({</span> <span class="ss">created_at: </span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="p">})</span>
<span class="p">{</span><span class="s2">"created_at"</span><span class="ss">:"2025-08-02 13:03:32 +0200"</span><span class="p">}</span>
</code></pre></div></div>

<p>But we can instruct it to instead serialize <code class="language-plaintext highlighter-rouge">Time</code> using the ISO8601 / <a href="https://datatracker.ietf.org/doc/html/rfc3339">RFC 3339</a>
format:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Time</span>
  <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">iso8601</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">to_json</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">generate</span><span class="p">({</span> <span class="ss">created_at: </span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="p">})</span>
<span class="p">{</span><span class="s2">"created_at"</span><span class="ss">:"2025-08-02T13:05:04.160+02:00"</span><span class="p">}</span>
</code></pre></div></div>

<p>This seems all well and good, but the problem, like for the <code class="language-plaintext highlighter-rouge">.json_create</code> method, is that this is a global behavior.
An application may very well need to serialize dates in different ways in different contexts.</p>

<p>Worse, in the context of a library, say an API client that needs to serialize <code class="language-plaintext highlighter-rouge">Time</code> in a specific way, it‚Äôs not really
possible to use this API, you can‚Äôt assume it‚Äôs acceptable to change such a global behavior, given you know nothing about the application in which you‚Äôll run.</p>

<p>So to me, there are two problems here. First, using <code class="language-plaintext highlighter-rouge">#to_s</code> as a fallback works for a few types, like date, but it is really not helpful
for the overwhelming majority of other objects:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">generate</span><span class="p">(</span><span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">)</span>
<span class="s2">"#&lt;Object:0x000000011ce214a0&gt;"</span>
</code></pre></div></div>

<p>I really can‚Äôt think of a situation in which this is the behavior that you want. If <code class="language-plaintext highlighter-rouge">JSON.generate</code> ends up calling <code class="language-plaintext highlighter-rouge">to_s</code> on an object, I‚Äôm willing to bet that in 99% of the time, the developer didn‚Äôt intend for that object to be serialized, or forgot to implement a <code class="language-plaintext highlighter-rouge">#to_json</code> on it.</p>

<p>Either way, it would be way more useful to raise an error, and requires that an explicit method to serialize that unknown object be provided.</p>

<p>The second is that it should be possible to customize a given type serialization locally, instead of globally.</p>

<p>In addition, returning a String as a JSON fragment is also not great, because it means recursively calling generators, and
allows to generate invalid documents:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Broken</span>
  <span class="k">def</span> <span class="nf">to_json</span>
    <span class="nb">to_s</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="o">&gt;&gt;</span> <span class="no">Broken</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">to_json</span>
<span class="o">=&gt;</span> <span class="s2">"#&lt;Broken:0x0000000123054050&gt;"</span>
<span class="o">&gt;&gt;</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="no">Broken</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">to_json</span><span class="p">)</span>
<span class="c1">#&gt; JSON::ParserError: unexpected character: '#&lt;Broken:0x000000011c9377a0&gt;'</span>
<span class="c1"># &gt; at line 1 column 1 </span>
</code></pre></div></div>

<p>That‚Äôs the problems the new <code class="language-plaintext highlighter-rouge">JSON::Coder</code> API is meant to solve.</p>

<p>By default, <code class="language-plaintext highlighter-rouge">JSON::Coder</code> only accepts to serialize types that have a direct JSON equivalent, so <code class="language-plaintext highlighter-rouge">Hash</code>, <code class="language-plaintext highlighter-rouge">Array</code>, <code class="language-plaintext highlighter-rouge">String</code> / <code class="language-plaintext highlighter-rouge">Symbol</code>,
<code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">Float</code>, <code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">false</code> and <code class="language-plaintext highlighter-rouge">nil</code>. Any type that doesn‚Äôt have a direct JSON equivalent produces an error:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="no">MY_JSON</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">::</span><span class="no">Coder</span><span class="p">.</span><span class="nf">new</span>
<span class="o">&gt;&gt;</span> <span class="no">MY_JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({</span><span class="ss">a: </span><span class="mi">1</span><span class="p">})</span>
<span class="o">=&gt;</span> <span class="s2">"{</span><span class="se">\"</span><span class="s2">a</span><span class="se">\"</span><span class="s2">:1}"</span>
<span class="o">&gt;&gt;</span> <span class="no">MY_JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({</span><span class="ss">a: </span><span class="no">Time</span><span class="p">.</span><span class="nf">new</span><span class="p">})</span>
<span class="c1">#&gt; JSON::GeneratorError: Time not allowed in JSON</span>
</code></pre></div></div>

<p>But it does allow you to provide a <code class="language-plaintext highlighter-rouge">Proc</code> to define the serialization of all other types:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MY_JSON</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">::</span><span class="no">Coder</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">obj</span><span class="o">|</span>
  <span class="k">case</span> <span class="n">obj</span>
  <span class="k">when</span> <span class="no">Time</span>
    <span class="n">obj</span><span class="p">.</span><span class="nf">iso8601</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">obj</span> <span class="c1"># return `obj` to fail serialization</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="o">&gt;&gt;</span> <span class="no">MY_JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({</span><span class="ss">a: </span><span class="no">Time</span><span class="p">.</span><span class="nf">new</span><span class="p">})</span>
<span class="o">=&gt;</span> <span class="s2">"{</span><span class="se">\"</span><span class="s2">a</span><span class="se">\"</span><span class="s2">:</span><span class="se">\"</span><span class="s2">2025-08-02T14:03:15.091+02:00</span><span class="se">\"</span><span class="s2">}"</span>
</code></pre></div></div>

<p>Contrary to the <code class="language-plaintext highlighter-rouge">#to_json</code> method, here the Proc is expected to return a JSON primitive object, so you don‚Äôt have to
concern yourself with JSON escaping rules and such, which is much safer.</p>

<p>But if for some reason you do need to, you still can using <code class="language-plaintext highlighter-rouge">JSON::Fragment</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MY_JSON</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">::</span><span class="no">Coder</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">obj</span><span class="o">|</span>
  <span class="k">case</span> <span class="n">obj</span>
  <span class="k">when</span> <span class="no">SomeRecord</span>
    <span class="no">JSON</span><span class="o">::</span><span class="no">Fragment</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="nf">json_blob</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">obj</span> <span class="c1"># return `obj` to fail serialization</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>With this new API, it‚Äôs now much easier for a gem to customize JSON generation in a local way.</p>

<p>Now, as I said before, I absolutely don‚Äôt plan to deprecate <code class="language-plaintext highlighter-rouge">#to_json</code>, nor even the behavior that calls <code class="language-plaintext highlighter-rouge">#to_s</code> on unknown objects.
Even though I think it‚Äôs a bad API, and that its replacement is way superior, the <code class="language-plaintext highlighter-rouge">#to_json</code> method has been at the center of the <code class="language-plaintext highlighter-rouge">json</code>
gem from the beginning and would require a massive amount of work from the community to migrate out of.</p>

<p>The decision to deprecate an API should always weigh the benefits against the costs.
Here, the cost is so massive that it is unimaginable for me to even consider it.</p>

<h2 id="load_default_options--dump_default_options">load_default_options / dump_default_options</h2>

<p>Another set of APIs I‚Äôve marked as deprecated are the various <code class="language-plaintext highlighter-rouge">_default_options</code> accessors.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="s2">"http://example.com"</span><span class="p">)</span>
<span class="s2">"http://example.com"</span>
<span class="o">&gt;&gt;</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">dump_default_options</span><span class="p">[</span><span class="ss">:script_safe</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="s2">"http://example.com"</span><span class="p">)</span>
<span class="s2">"http:</span><span class="se">\/\/</span><span class="s2">example.com"</span>
</code></pre></div></div>

<p>The concept is simple: you can globally change the default options received by certain methods.</p>

<p>At first sight, this might seem like a convenience, it allows you to set some option without having to pass it around
at potentially dozens of different call sites.</p>

<p>But just like <code class="language-plaintext highlighter-rouge">#to_json</code> and other APIs, this change applies to the entire application, including some dependencies that may
not expect standard JSON methods to behave differently.</p>

<p>And that‚Äôs not a hypothetical, I personally ran into a gem that was using JSON to fingerprint some object graphs, e.g.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fingerpint</span>
  <span class="no">Digest</span><span class="o">::</span><span class="no">SHA1</span><span class="p">.</span><span class="nf">hexdigest</span><span class="p">(</span><span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">some_object_graph</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div></div>

<p>That fingerprinting method was well tested in the gem, and was working well in a few dozen applications until one
day someone reported a bug in the gem. After some investigation, I figured the host application in question
had modified <code class="language-plaintext highlighter-rouge">JSON.dump_default_options</code>, causing the fingerprints to be different.</p>

<p>If you think about it, these sorts of global settings aren‚Äôt very different from monkey patching:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">JSON</span><span class="p">.</span><span class="nf">singleton_class</span><span class="p">.</span><span class="nf">prepend</span><span class="p">(</span><span class="no">Module</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
  <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">proc</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">opts</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="ss">script_safe: </span><span class="kp">true</span><span class="p">)</span>
    <span class="k">super</span>
  <span class="k">end</span>
<span class="p">})</span>
</code></pre></div></div>

<p>The overwhelming majority of Rubyists are very aware of the potential pitfalls of monkey patching, and some absolutely loathe it,
yet, these sorts of global configuration APIs don‚Äôt get frowned upon as much for some reason.</p>

<p>In some cases, they make sense. e.g. if the configuration is for an application, or a framework (a framework essentially being an application skeleton),
there‚Äôs not really a need for local configuration, and a global one is simpler and easier to reason about.
But in a library, that may in turn be used by multiple other libraries with different configuration needs, they‚Äôre a problem.</p>

<p>Amusingly, <a href="https://bugs.ruby-lang.org/issues/21311#Avoiding-unexpected-globally-shared-modulesobjects">this sort of API was one of the justifications for the currently experimental namespace feature in Ruby 3.5.0dev</a>,
which shows the <code class="language-plaintext highlighter-rouge">json</code> gem is not the only one with this problem.</p>

<p>Here again, a better solution is the <code class="language-plaintext highlighter-rouge">JSON::Coder</code> API, if you want to centralize your JSON generation configuration across
your codebase, you can allocate a singleton with your desired options:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">MyLibrary</span>
  <span class="no">JSON_CODER</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">::</span><span class="no">Coder</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">script_safe: </span><span class="kp">true</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">do_things</span>
    <span class="no">JSON_CODER</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>As a library author, you can even allow your users to substitute the configuration for one of their choosing:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">MyLibrary</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="nb">attr_accessor</span> <span class="ss">:json_coder</span>
  <span class="k">end</span>
  <span class="vi">@json_coder</span> <span class="o">=</span> <span class="no">JSON</span><span class="o">::</span><span class="no">Coder</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">script_safe: </span><span class="kp">true</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">do_things</span>
    <span class="no">MyLibrary</span><span class="p">.</span><span class="nf">json_coder</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Thankfully, from what I can see of the gem‚Äôs usage, these API were very rarely used, so while they‚Äôre not a major hindrance,
I figured the cost vs benefit is positive. And if someone really needs to set an option globally, they can monkey-patch JSON,
the effect is the same, and at least it‚Äôs more honest.</p>

<h2 id="conclusion">Conclusion</h2>

<p>As mentioned previously, the decision to deprecate shouldn‚Äôt be taken lightly.
It‚Äôs important to have empathy for the users who will have to deal with the fallout,
and there are a few things more annoying than cosmetic deprecations.</p>

<p>Yet it is also important to recognize when an API is error-prone or even outright dangerous,
and deprecations are sometimes a necessary evil to correct course.</p>

<p>Also, as you probably noticed, a common theme in most of the APIs I don‚Äôt like in the <code class="language-plaintext highlighter-rouge">json</code> gem, is global behavior and configuration.
I‚Äôm not certain why that is. A part of it might be that as Rubyists we value simplicity and conciseness, and that historically
the community has built its ethos as a reaction against overly verbose and ceremonial enterprise Java APIs, with their dependency injection frameworks and whatnot.</p>

<p>A bit of global state or behavior can sometimes bring a lot of simplicity, but it‚Äôs a very sharp tool that needs to be handled with extreme care.</p>

  </div><a class="u-url" href="/ruby/json/2025/08/02/whats-wrong-with-the-json-gem-api.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">byroot&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">byroot&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://bsky.app/profile/byroot.bsky.social"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#bluesky"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://www.twitter.com/_byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_byroot</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Various ramblings.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
