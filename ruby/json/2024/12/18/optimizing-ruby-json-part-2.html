<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Optimizing Ruby’s JSON, Part 2 | byroot’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Optimizing Ruby’s JSON, Part 2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In the previous post, I covered my motivations for improving ruby/json’s performance, and detailed the first 4 notable optimizations applied to speed up JSON generation." />
<meta property="og:description" content="In the previous post, I covered my motivations for improving ruby/json’s performance, and detailed the first 4 notable optimizations applied to speed up JSON generation." />
<link rel="canonical" href="/ruby/json/2024/12/18/optimizing-ruby-json-part-2.html" />
<meta property="og:url" content="/ruby/json/2024/12/18/optimizing-ruby-json-part-2.html" />
<meta property="og:site_name" content="byroot’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-12-18T16:05:51+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Optimizing Ruby’s JSON, Part 2" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-18T16:05:51+00:00","datePublished":"2024-12-18T16:05:51+00:00","description":"In the previous post, I covered my motivations for improving ruby/json’s performance, and detailed the first 4 notable optimizations applied to speed up JSON generation.","headline":"Optimizing Ruby’s JSON, Part 2","mainEntityOfPage":{"@type":"WebPage","@id":"/ruby/json/2024/12/18/optimizing-ruby-json-part-2.html"},"url":"/ruby/json/2024/12/18/optimizing-ruby-json-part-2.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="byroot&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">byroot&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Optimizing Ruby&#39;s JSON, Part 2</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-12-18T16:05:51+00:00" itemprop="datePublished">Dec 18, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="/ruby/json/2024/12/15/optimizing-ruby-json-part-1.html">In the previous post</a>, I covered my motivations for improving <code class="language-plaintext highlighter-rouge">ruby/json</code>’s performance,
and detailed the first 4 notable optimizations applied to speed up JSON generation.</p>

<p>If I was to cover every single optimization applied, at this rate I’d end up with a dozen parts, so I’ll try to only focus on the one that made a
significant difference or used an interesting pattern.</p>

<h2 id="reducing-setup-cost---argument-parsing-edition">Reducing Setup Cost - Argument Parsing Edition</h2>

<p>As mentioned in Part 1, When your benchmark only serializes a few dozen bytes of JSON, you end up measuring the baseline overhead of 
operations needed before you get to the actual work you’re here to perform, what I call “setup cost”.</p>

<p>The very high setup cost of <code class="language-plaintext highlighter-rouge">ruby/json</code> made it perform poorly on micro-benchmarks compared to alternatives.</p>

<p>If you look at <a href="https://share.firefox.dev/3BAhuPi">the native profile</a> of <code class="language-plaintext highlighter-rouge">JSON.dump([1, "string", { a: 1, b: 2 }, [3, 4, 5]])</code>,
you can see that we only spend <code class="language-plaintext highlighter-rouge">39%</code> of the time in <code class="language-plaintext highlighter-rouge">cState_generate</code> which is where we’re actually generating JSON, everything else is the setup cost.</p>

<p><img src="/assets/articles/json-2/micro-bench-flamegraph.png" alt="" /></p>

<p>So if we want to make <code class="language-plaintext highlighter-rouge">ruby/json</code> look good on micro-benchmarks, the setup cost is what need to be reduced.</p>

<p>And a big part of that was how <code class="language-plaintext highlighter-rouge">JSON.dump</code> parses the arguments it receives, because <code class="language-plaintext highlighter-rouge">JSON.dump</code> is one of these cursed methods that can be used in
way too many different ways. Aside from the first argument which is the object to serialize, <code class="language-plaintext highlighter-rouge">dump</code> accepts 3 positional arguments that are all optional.</p>

<p>In RDoc style, the signature would be <code class="language-plaintext highlighter-rouge">dump(obj, [anIo], [depth_limit], [options])</code>. This sort of signature is quite common in old gems that predate the
introduction of keyword arguments back in Ruby 2.0, and often cause an explosion of call patterns.</p>

<p>Here are 7 different ways the method can be called.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({})</span> <span class="c1"># =&gt; "{}"</span>
<span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({},</span> <span class="mi">12</span><span class="p">)</span> <span class="c1"># =&gt; "{}"</span>
<span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({},</span> <span class="mi">12</span><span class="p">,</span> <span class="ss">strict: </span><span class="kp">true</span><span class="p">)</span> <span class="c1"># =&gt; "{}"</span>
<span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({},</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"/tmp/foo.json"</span><span class="p">,</span> <span class="s2">"w+"</span><span class="p">))</span> <span class="c1"># =&gt; #&lt;File:/tmp/foo.json&gt;</span>
<span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({},</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"/tmp/foo.json"</span><span class="p">,</span> <span class="s2">"w+"</span><span class="p">),</span> <span class="mi">12</span><span class="p">)</span> <span class="c1"># =&gt; #&lt;File:/tmp/foo.json&gt;</span>
<span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({},</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"/tmp/foo.json"</span><span class="p">,</span> <span class="s2">"w+"</span><span class="p">),</span> <span class="mi">12</span><span class="p">,</span> <span class="ss">strict: </span><span class="kp">true</span><span class="p">)</span> <span class="c1"># =&gt; #&lt;File:/tmp/foo.json&gt;</span>
<span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">({},</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"/tmp/foo.json"</span><span class="p">,</span> <span class="s2">"w+"</span><span class="p">),</span> <span class="ss">strict: </span><span class="kp">true</span><span class="p">)</span> <span class="c1"># =&gt; #&lt;File:/tmp/foo.json&gt;</span></code></pre></figure>

<p>Here’s how the argument parsing was implemented:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">anIO</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">io_limit_opt</span> <span class="o">=</span> <span class="p">[</span><span class="n">anIO</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">].</span><span class="nf">compact</span>
  <span class="n">kwargs</span> <span class="o">=</span> <span class="n">io_limit_opt</span><span class="p">.</span><span class="nf">pop</span> <span class="k">if</span> <span class="n">io_limit_opt</span><span class="p">.</span><span class="nf">last</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span>
  <span class="n">anIO</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">io_limit_opt</span>
  <span class="k">if</span> <span class="n">anIO</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_io</span><span class="p">)</span>
    <span class="n">anIO</span> <span class="o">=</span> <span class="n">anIO</span><span class="p">.</span><span class="nf">to_io</span>
  <span class="k">elsif</span> <span class="n">limit</span><span class="p">.</span><span class="nf">nil?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">anIO</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:write</span><span class="p">)</span>
    <span class="n">anIO</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">anIO</span>
  <span class="k">end</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">dump_default_options</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="ss">:max_nesting</span> <span class="o">=&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="k">if</span> <span class="n">limit</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="n">merge_dump_options</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">kwargs</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">generate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">anIO</span>
    <span class="n">anIO</span><span class="p">.</span><span class="nf">write</span> <span class="n">result</span>
    <span class="n">anIO</span>
  <span class="k">else</span>
    <span class="n">result</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="no">JSON</span><span class="o">::</span><span class="no">NestingError</span>
  <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"exceed depth limit"</span>
<span class="k">end</span></code></pre></figure>

<p>There are a number of operations in there that are reasonably costly in abstract, but costly enough that you don’t want to use them in hot spots.</p>

<p>The first one is <code class="language-plaintext highlighter-rouge">[anIO, limit, kwargs].compact</code>, which is used to ignore <code class="language-plaintext highlighter-rouge">nil</code> arguments. It’s quite pleasing to the eye, and fairly idiomatic Ruby,
but it means one extra allocation, which is a lot on micro-benchmarks.</p>

<p>The alternative we’re trying to catch up to, only allocates a single object on its equivalent path, the returned JSON document as a String.
But <code class="language-plaintext highlighter-rouge">ruby/json</code> also need to allocate the <code class="language-plaintext highlighter-rouge">JSON::Generator::State</code> object, so that’s a total of 3 allocations, 3 times as much as <code class="language-plaintext highlighter-rouge">oj</code> or <code class="language-plaintext highlighter-rouge">rapidjson-ruby</code>.</p>

<p>Allocations aren’t that big of a problem on modern Ruby, it’s actually quite fast, the problem is that allocating will ultimately trigger the GC,
and while that too is negligible when doing a meaningful amount of work, it’s a huge proportion of the runtime in a micro-benchmark.</p>

<p><img src="/assets/articles/json-2/setup-cost-flamegraph.png" alt="" /></p>

<p>Then, there’s the <code class="language-plaintext highlighter-rouge">respond_to?(:to_io)</code> call (and sometimes the second one), which too is totally mundane and idiomatic Ruby code, but something
you want to avoid in hot paths.</p>

<p><code class="language-plaintext highlighter-rouge">respond_to?</code> does all the same work a method call does to find which method to call, but the major difference is that method calls have an inline cache
while <code class="language-plaintext highlighter-rouge">respond_to?</code> doesn’t, so it has to do more work than most method calls.</p>

<h3 id="method-lookup">Method Lookup</h3>

<p>To give you an idea of how much work looking up a method without a cache can entail, here is what it would look like if implemented in Ruby</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nf">respond_to?</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">ancestor</span><span class="o">|</span>
      <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">ancestor</span><span class="p">.</span><span class="nf">methods_hash</span><span class="p">.</span><span class="nf">key?</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="c1"># object doesn't respond to `method` but maybe it has a `respond_to_missing?` method.</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">ancestor</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">respond_to_missing</span> <span class="o">=</span> <span class="n">ancestor</span><span class="p">.</span><span class="nf">methods_hash</span><span class="p">[</span><span class="ss">:respond_to_missing?</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">respond_to_missing</span><span class="p">.</span><span class="nf">bind_call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>If you assume most of the time <code class="language-plaintext highlighter-rouge">anIO</code> is <code class="language-plaintext highlighter-rouge">nil</code>, that’s a lot of needless hash lookups, because <code class="language-plaintext highlighter-rouge">nil</code> has way more ancestors than you’d think:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">p</span> <span class="kp">nil</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># =&gt; 4</span>
<span class="nb">require</span> <span class="s2">"json"</span>
<span class="nb">p</span> <span class="kp">nil</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># =&gt; 6</span>
<span class="nb">require</span> <span class="s2">"active_support/all"</span>
<span class="nb">p</span> <span class="kp">nil</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">size</span> <span class="c1"># =&gt; 9</span></code></pre></figure>

<p>And on a miss, you might actually have to do all that a second time, to check if perhaps that class implements <code class="language-plaintext highlighter-rouge">#respond_to_missing</code>.</p>

<p>As mentioned, calling a method conceptually requires as much work, however, most method calls don’t result in a <code class="language-plaintext highlighter-rouge">NoMethodError</code> so you normally don’t
go all the way up the ancestor chain, and more importantly method calls have inline caches.</p>

<h3 id="inline-caches">Inline Caches</h3>

<p><a href="https://railsatscale.com/2023-10-24-memoization-pattern-and-object-shapes/#inline-caches">I touched a bit on what inline caches are last year in my post about object shapes</a>,
but to reiterate here, when Ruby compiles your code into YARV bytecode, for every method call it leaves a little bit of space called an inline cache.</p>

<p>For instance, if Ruby has to execute <code class="language-plaintext highlighter-rouge">nil.bar</code>, it will compile that into an <code class="language-plaintext highlighter-rouge">opt_send_without_block</code> instruction:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sx">%{nil.bar}</span><span class="p">).</span><span class="nf">disasm</span>
<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt;</span>
<span class="mo">0000</span> <span class="n">putnil</span>                                                           <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0001</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:bar</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0003</span> <span class="n">leave</span></code></pre></figure>

<p>Which down the line will end up in []<code class="language-plaintext highlighter-rouge">vm_search_method_fastpath</code>](https://github.com/ruby/ruby/blob/8417d09f9381c93352fe2cddbdfd4144b5924979/vm_insnhelper.c#L2256-L2279), that has access to <code class="language-plaintext highlighter-rouge">cc</code> AKA a “callcache”.
The actual method is a bit hard to read with lots of asserts etc, but here’s a stripped-down version that should be easy to understand:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rb_callcache</span> <span class="o">*</span>
<span class="nf">vm_search_method_fastpath</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">cd_owner</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_call_data</span> <span class="o">*</span><span class="n">cd</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">rb_callcache</span> <span class="o">*</span><span class="n">cc</span> <span class="o">=</span> <span class="n">cd</span><span class="o">-&gt;</span><span class="n">cc</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">klass</span> <span class="o">==</span> <span class="n">klass</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">cme</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INVALIDATED_FLAG</span><span class="p">))))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">cc</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">vm_search_method_slowpath0</span><span class="p">(</span><span class="n">cd_owner</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">klass</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>So in short, every single call site has a cache that contains the class of the last object this method was called on, and the result of the previous search.
Revalidating that cache is just a simple pointer comparison and a check in a bitmap to ensure the cache wasn’t invalidated.</p>

<p>That is a ton less work than the slow path, and since in practice most call sites are “monomorphic”, meaning they only ever apply to a single type,
this cache hit rate is fairly high.</p>

<p>The problem with <code class="language-plaintext highlighter-rouge">respond_to?</code> is that the name of the method we’re looking for is passed as an argument:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="nb">puts</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="sx">%{nil.respond_to?(:bar)}</span><span class="p">).</span><span class="nf">disasm</span>
<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,21)&gt;</span>
<span class="mo">0000</span> <span class="n">putnil</span>                                                           <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0001</span> <span class="n">putobject</span>                              <span class="ss">:bar</span>
<span class="mo">0003</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:respond_to?</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0005</span> <span class="n">leave</span></code></pre></figure>

<p>So here we have a call cache to lookup <code class="language-plaintext highlighter-rouge">respond_to?</code> on <code class="language-plaintext highlighter-rouge">nil</code>, but nowhere to cache the lookup of <code class="language-plaintext highlighter-rouge">bar</code>.</p>

<p>It actually wouldn’t be too hard to add such a cache, we’d need to modify the Ruby compiler to compile
<code class="language-plaintext highlighter-rouge">respond_to?</code> calls into a specialized <code class="language-plaintext highlighter-rouge">opt_respond_to</code> instruction that does have two caches instead of one.
The first cache would be used to look up <code class="language-plaintext highlighter-rouge">respond_to?</code> on the object to make sure it wasn’t redefined,
and the second one to look up the method we’re interested in. Or perhaps even 3 caches, as you also need to
check if the object has a <code class="language-plaintext highlighter-rouge">respond_to_missing?</code> method defined in some cases.</p>

<p>That’s an idea I remember discussing in the past with some fellow committers, but I can’t quite remember if
there was a reason we didn’t do it yet.</p>

<h3 id="nested-caching">Nested Caching</h3>

<p>That said, even without inline caches, <code class="language-plaintext highlighter-rouge">respond_to?</code> usually avoids doing the full method lookup.</p>

<p>Given how horrendously expensive they are, method lookups have two layers of cache.is
Inside the <code class="language-plaintext highlighter-rouge">Class</code> object structure, there is a field called <code class="language-plaintext highlighter-rouge">cc_tbl</code> for “call cache table”.
That’s essentially a Hash with method names as keys, and “call caches” as values.</p>

<p>So <code class="language-plaintext highlighter-rouge">respond_to?</code>’s implementation is actually more like this:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nf">respond_to?</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">call_cache</span><span class="p">[</span><span class="nb">method</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method_entry</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">search_method_with_cache</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
      <span class="kp">true</span>
    <span class="k">else</span>
      <span class="n">respond_to_missing_cc</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">call_cache</span><span class="p">[</span><span class="nb">method</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">respond_to_missing</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">search_method_with_cache</span><span class="p">(</span><span class="ss">:respond_to_missing?</span><span class="p">,</span> <span class="n">cc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">respond_to_missing</span><span class="p">.</span><span class="nf">bind_call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>So it’s thankfully much less work than an uncached method lookup, but when <code class="language-plaintext highlighter-rouge">respond_to?</code> returns <code class="language-plaintext highlighter-rouge">false</code>
we’re still doing at least two hash lookups to get the corresponding call caches.</p>

<p>So you can see how calling <code class="language-plaintext highlighter-rouge">respond_to?</code> on <code class="language-plaintext highlighter-rouge">nil</code> is a bit of a waste.</p>

<h3 id="cheaper-argument-parsing">Cheaper Argument Parsing</h3>

<p>But enough digression, and back to the problem at hand.</p>

<p>In most cases, none of these options are set, so the goal is to avoid allocating an array,
and avoid <code class="language-plaintext highlighter-rouge">respond_to?</code> when possible, <a href="https://github.com/ruby/json/pull/616">which led me to rewrite <code class="language-plaintext highlighter-rouge">dump</code> as this</a>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">anIO</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">kwargs</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="k">if</span> <span class="n">limit</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="k">if</span> <span class="n">anIO</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">anIO</span>
        <span class="n">anIO</span> <span class="o">=</span> <span class="kp">nil</span>
      <span class="k">end</span>
    <span class="k">elsif</span> <span class="n">limit</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span>
      <span class="n">kwargs</span> <span class="o">=</span> <span class="n">limit</span>
      <span class="n">limit</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="n">anIO</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="k">if</span> <span class="n">anIO</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_io</span><span class="p">)</span>
      <span class="n">anIO</span> <span class="o">=</span> <span class="n">anIO</span><span class="p">.</span><span class="nf">to_io</span>
    <span class="k">elsif</span> <span class="n">limit</span><span class="p">.</span><span class="nf">nil?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">anIO</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:write</span><span class="p">)</span>
      <span class="n">anIO</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">anIO</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">opts</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">dump_default_options</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="ss">:max_nesting</span> <span class="o">=&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="k">if</span> <span class="n">limit</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="n">merge_dump_options</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">kwargs</span>

  <span class="k">begin</span>
    <span class="k">if</span> <span class="no">State</span> <span class="o">===</span> <span class="n">opts</span>
      <span class="n">opts</span><span class="p">.</span><span class="nf">generate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">anIO</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="no">State</span><span class="p">.</span><span class="nf">generate</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">anIO</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">JSON</span><span class="o">::</span><span class="no">NestingError</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">"exceed depth limit"</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>So instead of using <code class="language-plaintext highlighter-rouge">Array#compact</code>, we do multiple nested <code class="language-plaintext highlighter-rouge">if thing.nil?</code> checks. It’s more verbose, but much more efficient, allocations
free, and JIT very well.</p>

<p>The <code class="language-plaintext highlighter-rouge">is_a?(Hash)</code> calls are no performance concern on Ruby 3.2+ thanks to <a href="https://www.youtube.com/watch?v=qlq-iQGtCgs">John Howthorn’s stellar work</a>, so they can stay.</p>

<p>As for <code class="language-plaintext highlighter-rouge">respond_to?</code>, we can’t fully eliminate it, but at least we can avoid calling it when the variable is <code class="language-plaintext highlighter-rouge">nil</code>, which should be most of the time.</p>

<p>All this combined yielded a nice <code class="language-plaintext highlighter-rouge">16%</code> improvement on micro benchmarks:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>== Encoding small mixed (34 bytes)
ruby 3.4.0rc1 (2024-12-12 master 29caae9991) +YJIT +PRISM [arm64-darwin23]
Warming up --------------------------------------
               after   227.226k i/100ms
Calculating -------------------------------------
               after      2.415M (± 0.9%) i/s  (414.02 ns/i) -     12.270M in   5.080537s

Comparison:
              before:  2078464.1 i/s
               after:  2415336.1 i/s - 1.16x  faster
</code></pre></div></div>

<p>After I merged that patch, <a href="https://github.com/eregon">Benoit Daloze</a> a fellow Ruby committer and TruffleRuby lead, suggested a funny trick that is
used very effectively in the Ruby stdlib for optimizing this sort of signature:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">anIO</span> <span class="o">=</span> <span class="p">(</span><span class="n">no_args_set</span> <span class="o">=</span> <span class="kp">true</span><span class="p">;</span> <span class="kp">nil</span><span class="p">),</span> <span class="n">limit</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">no_args_set</span>
    <span class="c1"># do the whole argument parsing</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>
<span class="k">end</span></code></pre></figure>

<p>I love that trick because it exploits the fact that, like pretty much everything in Ruby, arguments’ default values are expressions.</p>

<p>This trick is most commonly used when you need to know if an argument was passed as <code class="language-plaintext highlighter-rouge">nil</code> or just not passed, <a href="https://github.com/ruby/ruby/blob/8417d09f9381c93352fe2cddbdfd4144b5924979/hash.rb#L37-L39">an example of that
is <code class="language-plaintext highlighter-rouge">Hash#initialize</code></a></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Hash</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">ifnone</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifnone_unset</span> <span class="o">=</span> <span class="kp">true</span><span class="p">),</span> <span class="ss">capacity: </span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="no">Primitive</span><span class="p">.</span><span class="nf">rb_hash_init</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">ifnone_unset</span><span class="p">,</span> <span class="n">ifnone</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>If it used the classic <code class="language-plaintext highlighter-rouge">ifnone = nil</code> signature, it wouldn’t be possible to differentiate <code class="language-plaintext highlighter-rouge">Hash.new</code> and <code class="language-plaintext highlighter-rouge">Hash.new(nil)</code>.</p>

<p>However in this case that trick didn’t make a measurable difference, so I didn’t include that suggestion, but I thought it was worth a mention.</p>

<h2 id="jump-tables">Jump Tables</h2>

<p>The previous optimization helped with the setup cost, but it was still way more expensive than it should.</p>

<p>So I went to craft an even more micro-benchmark, trying to reduce the time spent generating JSON to better see the setup cost:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">"json"</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">20_000_000</span>
<span class="n">obj</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="no">JSON</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p><img src="/assets/articles/json-2/setup-cost-flamegraph-2.png" alt="" /></p>

<p><a href="https://share.firefox.dev/41EtIkw">Full profile.</a></p>

<p>As you may have spotted on that flame graph, a huge part of the setup is spent in <code class="language-plaintext highlighter-rouge">rb_hash_aref</code> and <code class="language-plaintext highlighter-rouge">rb_hash_has_key</code>, which are the
C API equivalents of <code class="language-plaintext highlighter-rouge">Hash#[]</code> and <code class="language-plaintext highlighter-rouge">Hash#key?</code>.</p>

<p>And all of this was in the <code class="language-plaintext highlighter-rouge">JSON::Generator::State#configure</code> method, implemented in C this way:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define option_given_p(opts, key) RTEST(rb_funcall(opts, i_key_p, 1, key))
</span>
<span class="k">static</span> <span class="n">VALUE</span> <span class="nf">cState_configure</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">opts</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">GET_STATE</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">rb_check_convert_type</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">T_HASH</span><span class="p">,</span> <span class="s">"Hash"</span><span class="p">,</span> <span class="s">"to_hash"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NIL_P</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">rb_convert_type</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">T_HASH</span><span class="p">,</span> <span class="s">"Hash"</span><span class="p">,</span> <span class="s">"to_h"</span><span class="p">);</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">rb_hash_aref</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">ID2SYM</span><span class="p">(</span><span class="n">i_indent</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RTEST</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">Check_Type</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">T_STRING</span><span class="p">);</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">RSTRING_LEN</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">indent</span> <span class="o">=</span> <span class="n">fstrndup</span><span class="p">(</span><span class="n">RSTRING_PTR</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">indent_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">rb_hash_aref</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">ID2SYM</span><span class="p">(</span><span class="n">i_space</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RTEST</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">Check_Type</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">T_STRING</span><span class="p">);</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">RSTRING_LEN</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">space</span> <span class="o">=</span> <span class="n">fstrndup</span><span class="p">(</span><span class="n">RSTRING_PTR</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">space_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ....</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">ID2SYM</span><span class="p">(</span><span class="n">i_max_nesting</span><span class="p">);</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_nesting</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">option_given_p</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">VALUE</span> <span class="n">max_nesting</span> <span class="o">=</span> <span class="n">rb_hash_aref</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">RTEST</span><span class="p">(</span><span class="n">max_nesting</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">Check_Type</span><span class="p">(</span><span class="n">max_nesting</span><span class="p">,</span> <span class="n">T_FIXNUM</span><span class="p">);</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_nesting</span> <span class="o">=</span> <span class="n">FIX2LONG</span><span class="p">(</span><span class="n">max_nesting</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_nesting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p>Which again is very verbose and noisy because it’s in C, but is essentially the naive way you’d initialize some object state from an options hash:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">indent</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="ss">:indent</span><span class="p">]</span>
    <span class="vi">@indent</span> <span class="o">=</span> <span class="n">ensure_string</span><span class="p">(</span><span class="n">indent</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">space</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="ss">:space</span><span class="p">]</span>
    <span class="vi">@space</span> <span class="o">=</span> <span class="n">ensure_string</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>

  <span class="vi">@max_nesting</span> <span class="o">=</span> <span class="mi">100</span>
  <span class="k">if</span> <span class="n">opts</span><span class="p">.</span><span class="nf">key?</span><span class="p">(</span><span class="ss">:max_nesting</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_nesting</span> <span class="o">=</span> <span class="n">opts</span><span class="p">[</span><span class="ss">:max_nesting</span><span class="p">]</span>
      <span class="vi">@max_nesting</span> <span class="o">=</span> <span class="no">Integer</span><span class="p">(</span><span class="n">max_nesting</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="vi">@max_nesting</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h3 id="gccct">gccct</h3>

<p>On the surface, there is some weirdly inefficient code here, such as using:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">RTEST</span><span class="p">(</span><span class="n">rb_funcall</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">i_key_p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span></code></pre></figure>

<p>To check if the option hash contains a key. Calling a method from C is quite costly because, you guessed it, looking up a method without a cache is costly.
Here again, we don’t have an inline cache, so Ruby has yet another trick down its sleeve to not make the performance atrocious,
the <code class="language-plaintext highlighter-rouge">gccct</code>. No I’m not having a stroke, it’s the acronym for “Global Call Cache Cache Table”, and yes it’s a cache of caches.</p>

<p>I did write <a href="https://twitter.com/_byroot/status/1831417434223604146">a Twitter thread back in September that talked about the <code class="language-plaintext highlighter-rouge">gccct</code></a>, but since
that site is quite hostile to outsiders, I’ll repeat some of it here.</p>

<p>The <code class="language-plaintext highlighter-rouge">gccct</code> is just a big global array of exactly <code class="language-plaintext highlighter-rouge">1023</code> <code class="language-plaintext highlighter-rouge">call_cache</code> objects, so when you need to lookup a method and there’s no better cache you can use,
you use one of these global caches:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">GLOBAL_CALL_CACHE_CACHE_TABLE_SIZE</span> <span class="o">=</span> <span class="mi">1023</span>
<span class="no">GLOBAL_CALL_CACHE_CACHE_TABLE</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">GLOBAL_CALL_CACHE_CACHE_TABLE_SIZE</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">gccct_method_search</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
  <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">receiver</span><span class="p">.</span><span class="nf">class</span><span class="p">,</span> <span class="n">method_name</span><span class="p">].</span><span class="nf">hash</span> <span class="o">%</span> <span class="no">GLOBAL_CALL_CACHE_CACHE_TABLE_SIZE</span>
  <span class="n">call_cache</span> <span class="o">=</span> <span class="no">GLOBAL_CALL_CACHE_CACHE_TABLE</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
  <span class="n">cached_method_search</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">call_cache</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>It’s as simple as that, we do a digest of the receiver class and the method name, and use that as an offset inside the array to select a call cache.</p>

<p>Of course, it can be subject to collisions, so distinct calls can end up sharing the same cache and make it flip-flop, but it still offers some decent
hit rate for cheap, so it’s better than nothing.</p>

<p>But that’s yet another digression because ultimately we just don’t need that at all, given the C API exposes some C functions
that allow us to check if a key exists without needing to go through method lookup. I suspect this may have been implemented this way
a long time ago to also support Hash-like objects, but it really isn’t worth the overhead.</p>

<p>In another Pull Request, <a href="https://github.com/luke-gru">Luke Gruber</a> had done <a href="https://github.com/ruby/json/pull/512/files#diff-2f079e65e9070fc3350059dbb4804c04be215ff9bed44144ee68b4de90faf2a6R20-R27">a similar optimization for the parser initialization</a>,
rewriting <code class="language-plaintext highlighter-rouge">option_given_p</code> into:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">VALUE</span> <span class="nf">hash_has_key</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">hash</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Qundef</span> <span class="o">==</span> <span class="n">rb_hash_lookup2</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">Qundef</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Qtrue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Qfalse</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define option_given_p(opts, key) (RTEST(hash_has_key(opts, key)))</span></code></pre></figure>

<p>And I could probably have done the same here, but I had another, less conventional, idea.</p>

<h3 id="inversion-of-priorities">Inversion of Priorities</h3>

<p>There’s probably a name for that optimization, but if so I don’t know it.</p>

<p>When thinking about the problem, it occurred to me that there are 13 possible option keys we need to check,
but in the vast majority of cases, the hash will only contain a few of them.</p>

<p>By default <code class="language-plaintext highlighter-rouge">JSON.dump</code> starts from the <code class="language-plaintext highlighter-rouge">JSON.dump_default_options</code> global config, so if you call dump with no extra options, that’s what we’ll get:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c">  <span class="n">self</span><span class="p">.</span><span class="n">dump_default_options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">:</span><span class="n">max_nesting</span> <span class="o">=&gt;</span> <span class="nb">false</span><span class="p">,</span>
    <span class="o">:</span><span class="n">allow_nan</span>   <span class="o">=&gt;</span> <span class="nb">true</span><span class="p">,</span>
    <span class="o">:</span><span class="n">script_safe</span> <span class="o">=&gt;</span> <span class="nb">false</span><span class="p">,</span>
  <span class="p">}</span></code></pre></figure>

<p>Actually, out of these 3 keys, the third one is useless, as it’s already the default, so really most of the time we only have two keys to check.</p>

<p>So what if instead of doing one to two lookups for every possible key (13), we’d iterate over the provided keys and use a <a href="https://en.wikipedia.org/wiki/Branch_table">jump table</a>?</p>

<p>The problem, however, is to do jump tables in C, you need a <code class="language-plaintext highlighter-rouge">switch</code> statement with static values, and hash keys are Ruby symbol objects, hence we can’t statically
know their value because they’re defined at runtime.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">switch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">sym_max_nesting</span><span class="p">:</span> <span class="c1">// This is just not possible...</span>
    <span class="k">break</span><span class="p">;</span>
  
<span class="p">}</span></code></pre></figure>

<p>But what few people know, is that Ruby’s <code class="language-plaintext highlighter-rouge">case</code> statement do generate a jump table when possible. Let me show you:</p>

<p>By default Ruby’s <code class="language-plaintext highlighter-rouge">case</code> just compiles down to a series of <code class="language-plaintext highlighter-rouge">if / elsif</code>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="o">&lt;&lt;~</span><span class="no">RUBY</span><span class="p">).</span><span class="nf">disasm</span><span class="sh">
case key
when /foo/
  something
when /bar/
  something_else
end
</span><span class="no">RUBY</span>

<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(6,3)&gt;</span>
<span class="mo">0000</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0001</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:key</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">VCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0003</span> <span class="n">putobject</span>                              <span class="sr">/foo/</span>                     <span class="p">(</span>   <span class="mi">2</span><span class="p">)</span>
<span class="mo">0005</span> <span class="n">topn</span>                                   <span class="mi">1</span>
<span class="mo">0007</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:===</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">000</span><span class="mi">9</span> <span class="n">branchif</span>                               <span class="mi">22</span>
<span class="mo">0011</span> <span class="n">putobject</span>                              <span class="sr">/bar/</span>                     <span class="p">(</span>   <span class="mi">4</span><span class="p">)</span>
<span class="mo">0013</span> <span class="n">topn</span>                                   <span class="mi">1</span>
<span class="mo">0015</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:===</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0017</span> <span class="n">branchif</span>                               <span class="mi">27</span>
<span class="mo">001</span><span class="mi">9</span> <span class="n">pop</span>                                                              <span class="p">(</span>   <span class="mi">1</span><span class="p">)</span>
<span class="mo">0020</span> <span class="n">putnil</span>
<span class="mo">0021</span> <span class="n">leave</span>                                                            <span class="p">(</span>   <span class="mi">5</span><span class="p">)</span>
<span class="mo">0022</span> <span class="n">pop</span>                                                              <span class="p">(</span>   <span class="mi">2</span><span class="p">)</span>
<span class="mo">0023</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">3</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0024</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:something</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">VCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0026</span> <span class="n">leave</span>                                                            <span class="p">(</span>   <span class="mi">5</span><span class="p">)</span>
<span class="mo">0027</span> <span class="n">pop</span>                                                              <span class="p">(</span>   <span class="mi">4</span><span class="p">)</span>
<span class="mo">002</span><span class="mi">8</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">5</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">002</span><span class="mi">9</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:something_else</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">VCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0031</span> <span class="n">leave</span></code></pre></figure>

<p>If you’re not familar with YARV assembly, here’s the “desugared” Ruby version of it:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">if</span> <span class="n">key</span> <span class="o">===</span> <span class="sr">/foo/</span>
  <span class="n">something</span>
<span class="k">elsif</span> <span class="n">key</span> <span class="o">===</span> <span class="sr">/bar/</span>
  <span class="n">something_else</span>
<span class="k">end</span></code></pre></figure>

<p>So it’s not a jump table, just some syntax sugar for <code class="language-plaintext highlighter-rouge">if / elsif</code>.
But if all the <code class="language-plaintext highlighter-rouge">when</code> values are essentially static (this includes literal numbers, literal symbols and literal strings),
Ruby generates some slightly different bytecode:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">puts</span> <span class="no">RubyVM</span><span class="o">::</span><span class="no">InstructionSequence</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="o">&lt;&lt;~</span><span class="no">RUBY</span><span class="p">).</span><span class="nf">disasm</span><span class="sh">
case key
when :foo
  something
when :bar
  something_else
end
</span><span class="no">RUBY</span>

<span class="o">==</span> <span class="ss">disasm: </span><span class="c1">#&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(6,3)&gt;</span>
<span class="mo">0000</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">1</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0001</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:key</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">VCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0003</span> <span class="nb">dup</span>
<span class="mo">0004</span> <span class="n">opt_case_dispatch</span>                      <span class="o">&lt;</span><span class="n">cdhash</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">23</span>
<span class="mo">0007</span> <span class="n">putobject</span>                              <span class="ss">:foo</span>                      <span class="p">(</span>   <span class="mi">2</span><span class="p">)</span>
<span class="mo">000</span><span class="mi">9</span> <span class="n">topn</span>                                   <span class="mi">1</span>
<span class="mo">0011</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:===</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0013</span> <span class="n">branchif</span>                               <span class="mi">26</span>
<span class="mo">0015</span> <span class="n">putobject</span>                              <span class="ss">:bar</span>                      <span class="p">(</span>   <span class="mi">4</span><span class="p">)</span>
<span class="mo">0017</span> <span class="n">topn</span>                                   <span class="mi">1</span>
<span class="mo">001</span><span class="mi">9</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:===</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0021</span> <span class="n">branchif</span>                               <span class="mi">31</span>
<span class="mo">0023</span> <span class="n">pop</span>                                                              <span class="p">(</span>   <span class="mi">1</span><span class="p">)</span>
<span class="mo">0024</span> <span class="n">putnil</span>
<span class="mo">0025</span> <span class="n">leave</span>                                                            <span class="p">(</span>   <span class="mi">5</span><span class="p">)</span>
<span class="mo">0026</span> <span class="n">pop</span>                                                              <span class="p">(</span>   <span class="mi">2</span><span class="p">)</span>
<span class="mo">0027</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">3</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">002</span><span class="mi">8</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:something</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">VCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0030</span> <span class="n">leave</span>                                                            <span class="p">(</span>   <span class="mi">5</span><span class="p">)</span>
<span class="mo">0031</span> <span class="n">pop</span>                                                              <span class="p">(</span>   <span class="mi">4</span><span class="p">)</span>
<span class="mo">0032</span> <span class="n">putself</span>                                                          <span class="p">(</span>   <span class="mi">5</span><span class="p">)[</span><span class="no">Li</span><span class="p">]</span>
<span class="mo">0033</span> <span class="n">opt_send_without_block</span>                 <span class="o">&lt;</span><span class="n">calldata!mid</span><span class="ss">:something_else</span><span class="p">,</span> <span class="n">argc</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="no">FCALL</span><span class="o">|</span><span class="no">VCALL</span><span class="o">|</span><span class="no">ARGS_SIMPLE</span><span class="o">&gt;</span>
<span class="mo">0035</span> <span class="n">leave</span></code></pre></figure>

<p>The thing to notice here is the <code class="language-plaintext highlighter-rouge">opt_case_dispatch</code> instruction, which wasn’t present on the previous disassembly.
What this instruction does, is that it holds a Hash, of which the keys are the static values we use in the <code class="language-plaintext highlighter-rouge">when</code> statements
and the values are the bytecode offset to which to directly jump. The rest of the bytecode is the same, to be used as the fallback
if the <code class="language-plaintext highlighter-rouge">opt_case_dispatch</code> doesn’t match.</p>

<p>With this, we can check as many symbols as we want in somewhat constant time, all we had to do was to rewrite all that nasty C code in Ruby,
<a href="https://github.com/ruby/json/pull/617/commits/25db79dfaa8f019077ef7e713a5aa62ff6af4a99">which I did in the most straightforward way in a preparatory commit</a>.
That commit alone already brought a <code class="language-plaintext highlighter-rouge">3%</code> improvement, thanks to inline caches:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>== Encoding small mixed (34 bytes)
ruby 3.4.0rc1 (2024-12-12 master 29caae9991) +YJIT +PRISM [arm64-darwin23]
Warming up --------------------------------------
               after   230.150k i/100ms
Calculating -------------------------------------
               after      2.450M (± 0.5%) i/s  (408.23 ns/i) -     12.428M in   5.073603s

Comparison:
              before:  2370478.1 i/s
               after:  2449616.3 i/s - 1.03x  faster
</code></pre></div></div>

<p>But I then followed up in the same pull request, with <a href="https://github.com/ruby/json/pull/617/commits/a75c9eccfd35e1d6715b05cbd7ef4d83b1bc177e">a rewrite of <code class="language-plaintext highlighter-rouge">State#configure</code> to use a case dispatch</a>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">opts</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">opts</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_hash</span><span class="p">)</span>
      <span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="nf">to_hash</span>
    <span class="k">elsif</span> <span class="n">opts</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_h</span><span class="p">)</span>
      <span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span><span class="p">.</span><span class="nf">to_h</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">TypeError</span><span class="p">,</span> <span class="s2">"can't convert </span><span class="si">#{</span><span class="n">opts</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2"> into Hash"</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">opts</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">key</span>
    <span class="k">when</span> <span class="ss">:indent</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">indent</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">when</span> <span class="ss">:space</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">space</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>And that brought a further <code class="language-plaintext highlighter-rouge">11%</code> improvement:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>== Encoding small mixed (34 bytes)
ruby 3.4.0rc1 (2024-12-12 master 29caae9991) +YJIT +PRISM [arm64-darwin23]
Warming up --------------------------------------
               after   247.127k i/100ms
Calculating -------------------------------------
               after      2.645M (± 0.6%) i/s  (378.07 ns/i) -     13.345M in   5.045454s

Comparison:
              before:  2379291.6 i/s
               after:  2645019.6 i/s - 1.11x  faster
</code></pre></div></div>

<p>So the rewrite in Ruby was a win-win, less C code to maintain, and more efficiency overall.</p>

<h2 id="to-be-continued">To Be Continued</h2>

<p>I only talked about two small optimizations, but I digressed so much that it’s already longer than part one,
and I probably won’t have time to write in the next few days, so it’s probably best if I stop here for part two.</p>

<p>At this rate, and based only on the number of commits I haven’t yet covered, I may need 5 or 6 more parts,
but I hope I won’t have to disgress as much as the series progress, and not all commits may be worth talking about.</p>

  </div><a class="u-url" href="/ruby/json/2024/12/18/optimizing-ruby-json-part-2.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">byroot&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">byroot&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://bsky.app/profile/byroot.bsky.social"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#bluesky"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://www.twitter.com/_byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_byroot</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Various ramblings.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
