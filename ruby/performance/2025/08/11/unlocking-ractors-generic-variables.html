<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Unlocking Ractors: generic instance variables | byroot’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Unlocking Ractors: generic instance variables" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In two previous posts, I explained that one of the big blockers for Ractors’ viability is that while they’re supposed to run fully in parallel, in many cases, they’d perform worse than a single thread because there were numerous codepaths in the Ruby virtual machine and runtime that were still protected by the global VM lock." />
<meta property="og:description" content="In two previous posts, I explained that one of the big blockers for Ractors’ viability is that while they’re supposed to run fully in parallel, in many cases, they’d perform worse than a single thread because there were numerous codepaths in the Ruby virtual machine and runtime that were still protected by the global VM lock." />
<link rel="canonical" href="https://byroot.github.io/ruby/performance/2025/08/11/unlocking-ractors-generic-variables.html" />
<meta property="og:url" content="https://byroot.github.io/ruby/performance/2025/08/11/unlocking-ractors-generic-variables.html" />
<meta property="og:site_name" content="byroot’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-08-11T09:03:51+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Unlocking Ractors: generic instance variables" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-08-11T09:03:51+00:00","datePublished":"2025-08-11T09:03:51+00:00","description":"In two previous posts, I explained that one of the big blockers for Ractors’ viability is that while they’re supposed to run fully in parallel, in many cases, they’d perform worse than a single thread because there were numerous codepaths in the Ruby virtual machine and runtime that were still protected by the global VM lock.","headline":"Unlocking Ractors: generic instance variables","mainEntityOfPage":{"@type":"WebPage","@id":"https://byroot.github.io/ruby/performance/2025/08/11/unlocking-ractors-generic-variables.html"},"url":"https://byroot.github.io/ruby/performance/2025/08/11/unlocking-ractors-generic-variables.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png"><link type="application/atom+xml" rel="alternate" href="https://byroot.github.io/feed.xml" title="byroot&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">byroot&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Unlocking Ractors: generic instance variables</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-08-11T09:03:51+00:00" itemprop="datePublished">Aug 11, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In two previous posts, I explained that one of the big blockers for Ractors’ viability is that while they’re supposed
to run fully in parallel, in many cases, they’d perform worse than a single thread because there were numerous codepaths
in the Ruby virtual machine and runtime that were still protected by the global VM lock.</p>

<p>I also explained how I removed two of these contention points, <a href="/ruby/performance/2025/04/26/unlocking-ractors-object-id.html">the <code class="language-plaintext highlighter-rouge">object_id</code> method</a>,
and <a href="/ruby/performance/2025/05/24/unlocking-ractors-class-variables.html">class instance variables</a>.</p>

<p>Since then, the situation has improved quite drastically, as numerous other contentious points have been either eliminated or reduced by me and my former teammates.
I’m not going to make a post for each of them, as in most cases it boils down to the same <a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU technique</a>
I explained in the post about class instance variables.</p>

<p>But there’s one such contention point I find interesting and that I’d like to write about: the generic instance variables table.</p>

<h2 id="how-instance-variables-work">How Instance Variables Work</h2>

<p>As a Ruby user, you are likely familiar with the idea that everything is an object, and that is somewhat true, but that doesn’t mean all objects are equal.
I already touched on that subject in some of my previous posts, so I’ll do it quickly.</p>

<p>In the context of instance variables, in the Ruby VM you essentially have 3 or 4 types of objects, depending on how you count.</p>

<p>First, you have the “immediates”, small integers (<code class="language-plaintext highlighter-rouge">1</code>), booleans (<code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">false</code>), static symbols (<code class="language-plaintext highlighter-rouge">:foo</code>, but not dynamic symbols like <code class="language-plaintext highlighter-rouge">"bar".to_sym</code>), etc.
These are called immediates because they don’t actually exist in memory; they don’t have an allocated object slot on the heap.  Their reference <em>is</em> their value.
In other words, they’re just <a href="https://en.wikipedia.org/wiki/Tagged_pointer">tagged pointers</a>.</p>

<p>Hence, they can’t have instance variables, and Ruby will treat them as if they were frozen to maintain the illusion of parity with other objects:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="mi">42</span><span class="p">.</span><span class="nf">instance_variable_set</span><span class="p">(</span><span class="ss">:@test</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">2</span><span class="ss">:in</span> <span class="s1">'Kernel#instance_variable_set'</span><span class="p">:</span> <span class="n">can</span><span class="err">'</span><span class="n">t</span> <span class="n">modify</span> <span class="n">frozen</span> <span class="no">Integer</span><span class="p">:</span> <span class="mi">42</span> <span class="p">(</span><span class="no">FrozenError</span><span class="p">)</span>
</code></pre></div></div>

<p>Then you have the more regular <code class="language-plaintext highlighter-rouge">T_OBJECT</code>, for your user-defined classes.
In the case of <code class="language-plaintext highlighter-rouge">T_OBJECT</code>, instance variables are stored inside the object’s slot like an array.
Consider the following object with 3 instance variables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="vi">@b</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="vi">@c</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It will fit in the base <code class="language-plaintext highlighter-rouge">40B</code> object slot.
<code class="language-plaintext highlighter-rouge">16B</code> is being used for the object’s flags and a pointer to its class, and the remaining <code class="language-plaintext highlighter-rouge">24B</code> is used for the three instance variable references:</p>

<table>
  <thead>
    <tr>
      <th>flags</th>
      <th>klass</th>
      <th>@a</th>
      <th>@b</th>
      <th>@c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T_OBJECT</td>
      <td>0xffeff</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>In some cases, if an instance variable is added later and the slot is full, the Ruby VM may have to allocate a separate memory
region and “spill” the instance variables there, but this is actually fairly rare. The VM keeps track of how many variables
the instances of each class have, so if Ruby ever has to spill, every future instance of that class will be allocated in a larger slot.</p>

<p>The third type of objects are <code class="language-plaintext highlighter-rouge">T_CLASS</code> and <code class="language-plaintext highlighter-rouge">T_MODULE</code>. Since that was the topic of my previous post, I’ll be quick.
Class instance variables are laid out like for <code class="language-plaintext highlighter-rouge">T_OBJECT</code> except they’re in a “companion” slot.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span>
  <span class="vi">@a</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="vi">@b</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="vi">@c</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The layout of the class itself stores a reference to that “companion” slot:</p>

<table>
  <thead>
    <tr>
      <th>flags</th>
      <th>klass</th>
      <th>obj_fields</th>
      <th>…</th>
      <th>…</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T_CLASS</td>
      <td>0xffeaa</td>
      <td>0xffdddd</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>And that other slot is laid out exactly like a <code class="language-plaintext highlighter-rouge">T_OBJECT</code>, except its type is <code class="language-plaintext highlighter-rouge">T_IMEMO</code> for “Internal Memory”:</p>

<table>
  <thead>
    <tr>
      <th>flags</th>
      <th>klass</th>
      <th>@a</th>
      <th>@b</th>
      <th>@c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T_IMEMO/fields</td>
      <td>0xffeaa</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>That’s a type of object that, as a Ruby user, you can’t directly interact with, nor even get a reference to; they’re basically invisible.
But they are used internally by the VM to store various data in memory managed by the GC instead of using manual memory management with <code class="language-plaintext highlighter-rouge">malloc</code> and <code class="language-plaintext highlighter-rouge">free</code>.</p>

<p>And then you have all the other objects. <code class="language-plaintext highlighter-rouge">Hash</code>, <code class="language-plaintext highlighter-rouge">Array</code>, <code class="language-plaintext highlighter-rouge">String</code>, etc.
For these, the space inside the object slot is already used.
For example, a <code class="language-plaintext highlighter-rouge">String</code> slot is used to store the string <code class="language-plaintext highlighter-rouge">length</code>, <code class="language-plaintext highlighter-rouge">capacity</code>, and if it’s small enough, the bytes that compose the string itself, otherwise a pointer to a manually allocated buffer.</p>

<p>Yet, Ruby allows you to define any instance variables you want on a string:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">"test"</span>
<span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="nf">instance_variable_set</span><span class="p">(</span><span class="ss">:@test</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">.</span><span class="nf">instance_variable_get</span><span class="p">(</span><span class="ss">:@test</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">1</span>
</code></pre></div></div>

<p>To allow this, the VM has an internal hash table, which used to be called the <code class="language-plaintext highlighter-rouge">genivar_tbl</code>, for Generic Instance Variables Hash-Table, and that I renamed into <code class="language-plaintext highlighter-rouge">generic_fields_tbl_</code> as part of my work on <code class="language-plaintext highlighter-rouge">object_id</code>.</p>

<p>I previously explained how this works in <a href="/ruby/performance/2025/04/26/unlocking-ractors-object-id.html#generic-instance-variables">my post about the <code class="language-plaintext highlighter-rouge">object_id</code></a>
method, but I’ll reexplain here with a bit more detail, as it’s really the core topic.</p>

<p>Once again, I’ll use Ruby pseudo-code to make it easier:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">GenericIvarObject</span>
  <span class="no">GENERIC_FIELDS_TBL</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">compare_by_identity</span>

  <span class="k">def</span> <span class="nf">instance_variable_get</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ivar_shape</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
      <span class="no">RubyVM</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">buffer</span> <span class="o">=</span> <span class="no">GENERIC_FIELDS_TBL</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span>
          <span class="n">buffer</span><span class="p">[</span><span class="n">ivar_shape</span><span class="p">.</span><span class="nf">index</span><span class="p">]</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In that global hash, the keys are the reference to the objects, and the values are pointers to manually allocated buffers.
Inside the buffer, there is an array of references just like in a <code class="language-plaintext highlighter-rouge">T_OBJECT</code> or a <code class="language-plaintext highlighter-rouge">T_IMEMO/fields</code>.</p>

<p>This isn’t ideal for multiple reasons.</p>

<p>First, having to do a hash-lookup is way more expensive than reading at an offset like we do for <code class="language-plaintext highlighter-rouge">T_OBJECT</code>, or even chasing a reference
like we do for <code class="language-plaintext highlighter-rouge">T_CLASS</code> and <code class="language-plaintext highlighter-rouge">T_MODULE</code>.</p>

<p>But worse, if we’re in a multi-ractor scenario, we have to acquire the VM lock for the whole operation.
First, because that hash-table is global and not thread-safe, then because we must ensure that another Ractor can’t free that manually allocated buffer while we’re reading it<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<p>So now, you probably understand the problem.
Any code that reads or writes an instance variable in an object that isn’t a direct descendant of <code class="language-plaintext highlighter-rouge">Object</code> (actually <code class="language-plaintext highlighter-rouge">BasicObject</code>) nor <code class="language-plaintext highlighter-rouge">Module</code> is a contention point for Ractors.</p>

<h2 id="surely-that-isnt-common">Surely That Isn’t Common?</h2>

<p>Before I dig into what can be changed, you may wonder if it even matters.</p>

<p>And it’s a very fair question. Developer time isn’t unlimited, hence the question of whether it is worth removing a contention
points boil down to how hot a code path it is, and how hard it is to fix it.</p>

<p>When I started looking at this, it was from the angle of <code class="language-plaintext highlighter-rouge">T_STRUCT</code>.
I wanted the instance variable of <code class="language-plaintext highlighter-rouge">Struct</code> and <code class="language-plaintext highlighter-rouge">Data</code> objects
not to be contention points, e.g., it’s not that rare to see <code class="language-plaintext highlighter-rouge">Struct</code> being used as some sort of code generator:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Address</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:street</span><span class="p">,</span> <span class="ss">:city</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">something_else</span>
    <span class="vi">@something_else</span> <span class="o">||=</span> <span class="n">compute_something</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">Struct.new</code> and <code class="language-plaintext highlighter-rouge">Data.define</code> don’t create <code class="language-plaintext highlighter-rouge">T_OBJECT</code> but <code class="language-plaintext highlighter-rouge">T_STRUCT</code> objects.
In these, the space inside the slot is used for the declared fields, not for the ivars.</p>

<p>Another pattern I expected was C extensions. When a Ruby C extension needs to expose an API, it uses the <code class="language-plaintext highlighter-rouge">TypedData</code> API, which allows to create <code class="language-plaintext highlighter-rouge">T_DATA</code> objects.
But it’s not rare for extensions to do as little as possible in C, and to extend that C class with some Ruby.</p>

<p>An example of that is the <code class="language-plaintext highlighter-rouge">trilogy</code> gem, which <a href="https://github.com/trilogy-libraries/trilogy/blob/16667c95e8c2716a16e69e8325d6b0cb615591e2/contrib/ruby/ext/trilogy-ruby/cext.c#L1141-L1153">defines a bunch of C methods</a></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RUBY_FUNC_EXPORTED</span> <span class="kt">void</span> <span class="nf">Init_cext</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">Trilogy</span> <span class="o">=</span> <span class="n">rb_const_get</span><span class="p">(</span><span class="n">rb_cObject</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"Trilogy"</span><span class="p">));</span>
    <span class="n">rb_define_alloc_func</span><span class="p">(</span><span class="n">Trilogy</span><span class="p">,</span> <span class="n">allocate_trilogy</span><span class="p">);</span>

    <span class="n">rb_define_private_method</span><span class="p">(</span><span class="n">Trilogy</span><span class="p">,</span> <span class="s">"_connect"</span><span class="p">,</span> <span class="n">rb_trilogy_connect</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">rb_define_method</span><span class="p">(</span><span class="n">Trilogy</span><span class="p">,</span> <span class="s">"change_db"</span><span class="p">,</span> <span class="n">rb_trilogy_change_db</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">rb_define_alias</span><span class="p">(</span><span class="n">Trilogy</span><span class="p">,</span> <span class="s">"select_db"</span><span class="p">,</span> <span class="s">"change_db"</span><span class="p">);</span>
    <span class="n">rb_define_method</span><span class="p">(</span><span class="n">Trilogy</span><span class="p">,</span> <span class="s">"query"</span><span class="p">,</span> <span class="n">rb_trilogy_query</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But <a href="https://github.com/trilogy-libraries/trilogy/blob/16667c95e8c2716a16e69e8325d6b0cb615591e2/contrib/ruby/lib/trilogy.rb">then augment that C class with Ruby code</a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Trilogy</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">options</span><span class="p">[</span><span class="ss">:port</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:port</span><span class="p">].</span><span class="nf">to_i</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:port</span><span class="p">]</span>
    <span class="n">mysql_encoding</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:encoding</span><span class="p">]</span> <span class="o">||</span> <span class="s2">"utf8mb4"</span>
    <span class="n">encoding</span> <span class="o">=</span> <span class="no">Trilogy</span><span class="o">::</span><span class="no">Encoding</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">mysql_encoding</span><span class="p">)</span>
    <span class="n">charset</span> <span class="o">=</span> <span class="no">Trilogy</span><span class="o">::</span><span class="no">Encoding</span><span class="p">.</span><span class="nf">charset</span><span class="p">(</span><span class="n">mysql_encoding</span><span class="p">)</span>
    <span class="vi">@connection_options</span> <span class="o">=</span> <span class="n">options</span>
    <span class="vi">@connected_host</span> <span class="o">=</span> <span class="kp">nil</span>

    <span class="n">_connect</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="n">charset</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>That’s a pattern I really like, as it allows to write less C and more Ruby, so I would have hated having to complexify some C extensions so that they’d perform better under ractors.</p>

<p>Then you have a few classics, <a href="https://github.com/rails/rails/blob/3235827585d87661942c91bc81f64f56d710f0b2/activesupport/lib/active_support/core_ext/string/output_safety.rb#L19-L73">like <code class="language-plaintext highlighter-rouge">ActiveSupport::SafeBuffer</code></a>,
which is a subclass of <code class="language-plaintext highlighter-rouge">String</code> with a <code class="language-plaintext highlighter-rouge">@html_safe</code> instance variable:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveSupport</span>
  <span class="k">class</span> <span class="nc">SafeBuffer</span> <span class="o">&lt;</span> <span class="no">String</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">str</span> <span class="o">=</span> <span class="s2">""</span><span class="p">)</span>
      <span class="vi">@html_safe</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">super</span>
    <span class="k">end</span>

    <span class="c1"># ...snip</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So it’s not that rare for code to inherit from core types, and it can end up in hot spots.
Even though I would recommend avoiding it as much as possible, for reasons other than performance, sometimes it’s the pragmatic thing to do, so users do it.</p>

<h2 id="some-data-points">Some Data Points</h2>

<p>Regardless, I was quite convinced that improving this code path would be useful and started working on it.
But later on, I was asked to provide some data, so while I’m breaking the chronology here, let me share it with you.</p>

<p>I started by doing my favorite hack in the VM, a good old print gated by an environment variable:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"DEB"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">rb_obj_info</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Then I modified the <a href="https://github.com/Shopify/yjit-bench/"><code class="language-plaintext highlighter-rouge">yjit-bench</code> suite</a> to set <code class="language-plaintext highlighter-rouge">ENV["DEB"] = "1"</code> at the start
of the benchmarks loops, as I’m more interested in runtime codepaths than in boottime ones.</p>

<p>I then ran the <a href="https://github.com/Shopify/shipit-engine"><code class="language-plaintext highlighter-rouge">shipit</code></a> benchmark while redirecting STDERR to a file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bundle <span class="nb">exec </span>ruby benchmark.rb 2&gt; /tmp/ivar-stats.txt
</code></pre></div></div>

<p>And did some quick number crunching with <code class="language-plaintext highlighter-rouge">irb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">File</span><span class="p">.</span><span class="nf">readlines</span><span class="p">(</span><span class="s2">"/tmp/ivar-stats.txt"</span><span class="p">,</span> <span class="ss">chomp: </span><span class="kp">true</span><span class="p">).</span><span class="nf">tally</span><span class="p">.</span><span class="nf">sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:last</span><span class="p">).</span><span class="nf">reverse</span>
</code></pre></div></div>

<p>Here are some results. It’s a very vanilla Rails 8 application, nothing fancy:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
 <span class="p">[</span><span class="s2">"VM/thread"</span><span class="p">,</span> <span class="mi">4886969</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"T_HASH"</span><span class="p">,</span> <span class="mi">229501</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"SQLite3::Backup"</span><span class="p">,</span> <span class="mi">122531</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"T_STRING"</span><span class="p">,</span> <span class="mi">70597</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"xmlDoc"</span><span class="p">,</span> <span class="mi">23625</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"T_ARRAY"</span><span class="p">,</span> <span class="mi">9039</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"OpenSSL/Cipher"</span><span class="p">,</span> <span class="mi">2800</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"xmlNode"</span><span class="p">,</span> <span class="mi">2025</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"encoding"</span><span class="p">,</span> <span class="mi">358</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"time"</span><span class="p">,</span> <span class="mi">199</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"proc"</span><span class="p">,</span> <span class="mi">68</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"T_STRUCT"</span><span class="p">,</span> <span class="mi">38</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"OpenSSL/X509/STORE"</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"Psych/parser"</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="s2">"set"</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="p">]</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">T_STRUCT</code> was there as I expected, but entirely dwarfed by other types.
For the ones that aren’t obvious:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">"VM/Thread"</code> is literally <code class="language-plaintext highlighter-rouge">Thread</code> instances.</li>
  <li><code class="language-plaintext highlighter-rouge">xmlNode</code> and <code class="language-plaintext highlighter-rouge">xmlDoc</code> are <code class="language-plaintext highlighter-rouge">nokogiri</code> objects.</li>
  <li>Anything that doesn’t start with <code class="language-plaintext highlighter-rouge">T_</code>, is a <code class="language-plaintext highlighter-rouge">T_DATA</code>.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">T_HASH</code> I definitely didn’t expect, and it wasn’t clear where it was coming from. So I did another hack:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">"DEB"</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">TYPE_P</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">T_HASH</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rb_bug</span><span class="p">(</span><span class="s">"here"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">rb_bug</code> function causes the RubyVM to abort and print its crash report, which does contain the Ruby level-backtrace.
With that, I figured these were <a href="https://github.com/rack/rack/blob/9163ac3f5fac795179f9935e2ba6533a0ca1cf82/lib/rack/utils.rb#L436-L449"><code class="language-plaintext highlighter-rouge">Rack::Utils::HeaderHash</code></a> instances.</p>

<p>As for the <code class="language-plaintext highlighter-rouge">T_ARRAY</code>, it seems like it was mostly from <a href="https://github.com/rails/rails/blob/bb3ddbf032c3a24c2c94f911c8c5ca9f6939c6d9/activesupport/lib/active_support/inflector/inflections.rb#L33-L37"><code class="language-plaintext highlighter-rouge">ActiveSupport::Inflector::Inflections::Uncountables</code></a></p>

<p>And for <code class="language-plaintext highlighter-rouge">"VM/Thread"</code> it comes from <a href="https://github.com/rails/rails/blob/bb3ddbf032c3a24c2c94f911c8c5ca9f6939c6d9/activesupport/lib/active_support/isolated_execution_state.rb#L7-L8"><code class="language-plaintext highlighter-rouge">ActiveSupport::IsolatedExecutionState</code></a>.</p>

<p>All the rest was various <code class="language-plaintext highlighter-rouge">T_DATA</code> defined by C extensions, like the <code class="language-plaintext highlighter-rouge">trilogy</code> example I shared.</p>

<p>I ran a few other benchmarks from the <code class="language-plaintext highlighter-rouge">yjit-bench</code> repo, and often found similar generic instance variable usages.</p>

<p>So to answer the question, while it’s not that big of a hotspot, I believe it’s used enough to be worth optimizing, especially for <code class="language-plaintext highlighter-rouge">T_DATA</code>,
and not just because of Ractors.</p>

<h2 id="shaped-structs">Shaped Structs</h2>

<p>But as I said, before I got all that data, my sight was set on <code class="language-plaintext highlighter-rouge">T_STRUCT</code>.
Struct objects are laid out very similarly to <code class="language-plaintext highlighter-rouge">T_OBJECT</code> except that the space is used for “members” instead of instance variables.</p>

<p>For instance, the following struct:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">struct</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:field_1</span><span class="p">,</span> <span class="ss">:field_2</span><span class="p">).</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>Would be laid out as is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| flags    | klass   | field_1 | field_2 | - |
|----------|---------|---------|---------|---|
| T_STRUCT | 0xbbeaa | 1       | 2       |   |
</code></pre></div></div>

<p>Hence, my initial idea was that if we were to encode the struct’s layout using shapes like we do for instance variables, we’d
be able to collocate members and variables together so that:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MyStruct</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:field_1</span><span class="p">,</span> <span class="ss">:field_2</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="k">super</span>
    <span class="vi">@c</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Could be laid out as:</p>

<table>
  <thead>
    <tr>
      <th>flags</th>
      <th>klass</th>
      <th>field_1</th>
      <th>field_2</th>
      <th>@c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T_STRUCT</td>
      <td>0xffeaa</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Which would be perfect. Everything would be embedded in the object slot, so we’d have minimal memory usage and access times.</p>

<p>Unfortunately, after putting some more thought into it, I realized that was a major problem with it: complex shapes.
I <a href="https://railsatscale.com/2023-10-24-memoization-pattern-and-object-shapes/#shape_too_complex">previously wrote at length on what complex shapes are</a>, so very quickly,
in the Ruby VM, shapes aren’t garbage collected, so if some code generates a lot of different shapes, Ruby will deoptimize the object and use a hash table to store
its instance variables. It also does the same if the program uses all the possible shape slots.</p>

<p>So if <code class="language-plaintext highlighter-rouge">Struct</code> members were encoded with shapes, we’d need to have many fallback code paths to handle complex structs,
and for some of the struct APIs, that is straight out impossible, because Struct objects can be treated like arrays:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">).</span><span class="nf">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="mi">2</span>
</code></pre></div></div>

<p>In such a case, all we have is the member offset, so if the struct was deoptimized into a hash, we wouldn’t be able to look up members by index anymore, short of keeping a reverse index, but that’s really a lot of extra complexity.
So I abandoned this idea.</p>

<h2 id="shape-offset">Shape Offset</h2>

<p>A few days later, I was brainstorming with Étienne Barrié, and we thought of a simpler solution.
Instead of encoding struct members in shapes, we could introduce a new type of shape to encode at which offset the instance variables start.</p>

<p>As often mentioned, shapes are a tree, so an object with variables <code class="language-plaintext highlighter-rouge">@a -&gt; @b -&gt; @c -&gt; @d</code>, the shape tree would look like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ROOT_SHAPE</span>
  <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@a</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">0</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">3</span><span class="p">)</span>
    <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@b</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">3</span><span class="p">)</span>
      <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@c</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">3</span><span class="p">)</span>
        <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@d</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">3</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">8</span><span class="p">)</span>
</code></pre></div></div>

<p>With offset shapes, the same instance variable list, but for a struct with two members, would look like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ROOT_SHAPE</span>
  <span class="p">\</span><span class="o">-</span> <span class="no">Offset</span><span class="p">(</span><span class="ss">index: index: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">3</span><span class="p">)</span>
    <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@a</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">3</span><span class="p">)</span>
      <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@b</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">3</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">8</span><span class="p">)</span>
        <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@c</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">4</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">8</span><span class="p">)</span>
          <span class="p">\</span><span class="o">-</span> <span class="no">Ivar</span><span class="p">(</span><span class="ss">name: :@d</span><span class="p">,</span> <span class="ss">index: </span><span class="mi">5</span><span class="p">,</span> <span class="ss">capacity: </span><span class="mi">8</span><span class="p">)</span>
</code></pre></div></div>

<p>Here again, we’d need to handle the case where the Ruby VM ran out of shapes, but at least only the instance variables
would be deoptimized into a hash table, the struct members would still be laid out like an array, saving a ton of complexity.</p>

<p>That being said, while I still think this is a good idea, it’s a fairly big project with some uncertainties.
So when I evoked this solution with Peter Zhu, he suggested something much simpler.</p>

<h2 id="direct-references">Direct References</h2>

<p>The annoying thing with generic instance variables isn’t so much that they aren’t embedded inside the object’s slot, but that to find the companion slot, you need to go through that global hash table.</p>

<p>Of course, if they were embedded, it would mean better data locality, which is good for performance, but that really isn’t much compared to the hash-lookup, so a single pointer chase would already be a major win.</p>

<p>Hence, Peter’s suggestion was to just use empty space in struct slots to keep a direct reference to the buffer that holds
the instance variables, and since structs are basically fixed-size arrays, we can store that reference right after the
last struct member.</p>

<p>In pseudo-code, it would be more or less:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Struct</span>
  <span class="k">def</span> <span class="nf">instance_variable_get</span><span class="p">(</span><span class="n">ivar</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">__slot_capacity__</span> <span class="o">&gt;</span> <span class="n">size</span>
      <span class="nb">self</span><span class="p">[</span><span class="n">size</span><span class="p">].</span><span class="nf">instance_variable_get</span><span class="p">(</span><span class="n">ivar</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="c1"># use the generic instance variables table</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>That’s essentially the same strategy as with classes and modules.</p>

<p>At least on paper, that was quite easy because <a href="https://github.com/ruby/ruby/pull/13626">a few weeks prior, I had refactored the generic instance variables to use the same underlying managed object as classes</a>: <code class="language-plaintext highlighter-rouge">T_IMEMO/fields</code>.</p>

<p>Once again, <a href="https://github.com/ruby/ruby/pull/14095">I paired with Étienne Barrié to implement that idea</a>, but the resulting PR was way larger and more complex than I had hoped for, because of a lack of encapsulation.</p>

<p>In many places across the VM, when dealing with instance variables, you have a similar big <code class="language-plaintext highlighter-rouge">switch/case</code> statement with
a branch for each of the 3 or 4 possible types of object layouts.
So making <code class="language-plaintext highlighter-rouge">T_STRUCT</code> different would mean adding one more code path in all these places, which would leave me with a bad taste in my mouth.</p>

<p>That’s why I backtracked a bit and decided to start by <a href="https://github.com/ruby/ruby/pull/14107">refactoring the generic instance variables table, so that all accesses go through a very small number of functions</a>.
After that, all reads and writes to the table went through mostly just two functions, making it the perfect place to specialize the behavior for struct objects.</p>

<p>As a bit of a sidenote, the more I work on the Ruby VM, the more I realize the challenging part isn’t to come up with a brilliant idea,
or a clever algorithm, but the sheer effort required to refactor code without breaking everything.
The C language doesn’t have a lot of features for abstractions and encapsulation, so coupling is absolutely everywhere.</p>

<p>Anyways, with that refactoring done, I was able to re-implement <a href="https://github.com/ruby/ruby/pull/14129">the same pull request we did with Étienne, but half the size</a>, most of it being just tests, documentation, and benchmarking code.</p>

<p>Now the generic instance variable lookup function looks like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span>
<span class="nf">rb_obj_fields</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ID</span> <span class="n">field_name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RUBY_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">RB_TYPE_P</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">T_IMEMO</span><span class="p">));</span>
    <span class="n">ivar_ractor_check</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">field_name</span><span class="p">);</span>

    <span class="n">VALUE</span> <span class="n">fields_obj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rb_shape_obj_has_fields</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">BUILTIN_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">case</span> <span class="n">T_STRUCT</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">FL_TEST_RAW</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">RSTRUCT_GEN_FIELDS</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">fields_obj</span> <span class="o">=</span> <span class="n">RSTRUCT_FIELDS_OBJ</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// fall through</span>
          <span class="nl">default:</span>
            <span class="n">RB_VM_LOCKING</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st_lookup</span><span class="p">(</span><span class="n">generic_fields_tbl_</span><span class="p">,</span> <span class="p">(</span><span class="n">st_data_t</span><span class="p">)</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">st_data_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fields_obj</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">rb_bug</span><span class="p">(</span><span class="s">"Object is missing entry in generic_fields_tbl"</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fields_obj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When dealing with a <code class="language-plaintext highlighter-rouge">T_STRUCT</code> and if there’s some unused space in the slot, we entirely bypass the <code class="language-plaintext highlighter-rouge">generic_fields_tbl</code> and <code class="language-plaintext highlighter-rouge">RB_VM_LOCKING</code>.</p>

<p>And to ensure we don’t fall in the fallback path too much, we modified the Struct allocator to allocate a large enough slots for structs
that have instance variables:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">VALUE</span>
<span class="nf">struct_alloc</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">num_members</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">embedded_size</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">RStruct</span><span class="p">,</span> <span class="n">as</span><span class="p">.</span><span class="n">ary</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VALUE</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RCLASS_MAX_IV_COUNT</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">embedded_size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VALUE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// snip...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As a result, instance variable accesses in structs are now noticeably faster, even when no ractor is involved:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>compare-ruby: ruby 3.5.0dev (2025-08-06T12:50:36Z struct-ivar-fields-2 9a30d141a1) +PRISM [arm64-darwin24]
built-ruby: ruby 3.5.0dev (2025-08-06T12:57:59Z struct-ivar-fields-2 2ff3ec237f) +PRISM [arm64-darwin24]
warming up.....

|                      |compare-ruby|built-ruby|
|:---------------------|-----------:|---------:|
|member_reader         |    590.317k|  579.246k|
|                      |       1.02x|         -|
|member_writer         |    543.963k|  527.104k|
|                      |       1.03x|         -|
|member_reader_method  |    213.540k|  213.004k|
|                      |       1.00x|         -|
|member_writer_method  |    192.657k|  191.491k|
|                      |       1.01x|         -|
|ivar_reader           |    403.993k|  569.915k|
|                      |           -|     1.41x|
</code></pre></div></div>

<p>That was a satisfying change.</p>

<h2 id="generalizing-to-other-types">Generalizing to Other Types</h2>

<p>Now that we had a working pattern, the question was where else could we apply it.</p>

<p>I definitely knew instance variables on <code class="language-plaintext highlighter-rouge">T_STRING</code> are rather common, given I’m very familiar with <code class="language-plaintext highlighter-rouge">ActiveSupport::SafeBuffer</code>, so I thought about pulling a similar trick for them.</p>

<p>Unfortunately, what made this possible with <code class="language-plaintext highlighter-rouge">T_STRUCT</code> is that they are essentially fixed-size arrays.
Which means we know that whatever free space is left in the slot won’t ever be needed in the future.</p>

<p>Whereas other types like <code class="language-plaintext highlighter-rouge">T_STRING</code> and <code class="language-plaintext highlighter-rouge">T_ARRAY</code> are variable size.
If you start storing a reference in free space at the end of the slot, you then need to be very careful that if the user appends
to the string or array, it won’t overwrite that reference. That’s much harder to do and probably not worth the extra complexity.</p>

<p>But one of my favorite things with Ruby and Rails is to be able to optimize from both ends.
If some pattern Rails uses isn’t very performant, I can try to optimize Ruby, but I can also just change what Rails does.</p>

<p>In the case of <code class="language-plaintext highlighter-rouge">ActiveSupport::SafeBuffer</code>, all we’re storing is just a boolean: <code class="language-plaintext highlighter-rouge">@html_safe = true</code>, and eventually, if something is appended to the buffer, the flag will be flipped.
But appends into safe buffers are very rare.</p>

<p>Most of the time, <code class="language-plaintext highlighter-rouge">String#html_safe</code> is only used as a way to tag the string, to indicate that it doesn’t need to be escaped when it’s later appended into another buffer. In other words, the overwhelming majority of instances never flip that flag.</p>

<p>Based on that knowledge, <a href="https://github.com/rails/rails/pull/55352">I changed that variable to be a negative</a>.
Instead of starting with <code class="language-plaintext highlighter-rouge">@html_safe = true</code>, we can start with <code class="language-plaintext highlighter-rouge">@html_unsafe = false</code>, and since referencing an instance
variable that doesn’t exist evaluates to <code class="language-plaintext highlighter-rouge">nil</code>, which is also falsy, we can simply not set the variable at all.</p>

<p>The result made <code class="language-plaintext highlighter-rouge">String#html_safe</code> twice as fast, even when no Ractor is started:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby 3.5.0dev (2025-07-17T14:01:57Z master a46309d19a) +YJIT +PRISM [arm64-darwin24]
Calculating -------------------------------------
    String#html_safe (old)     6.421M (± 1.6%) i/s  (155.75 ns/i) -     32.241M in   5.022802s
    String#html_safe          12.470M (± 0.8%) i/s   (80.19 ns/i) -     63.140M in   5.063698s
</code></pre></div></div>

<p>I guess this is a good example of <a href="https://en.wiktionary.org/wiki/mechanical_sympathy">mechanical sympathy</a><sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>, the more you know about how the tools you are using work, the more effectively you can use them.</p>

<p>And now that I learned about <code class="language-plaintext highlighter-rouge">ActiveSupport::Inflector::Inflections::Uncountables</code>, I should probably change it in a similar way.</p>

<p>But the one other type that I thought was worth attention to was <code class="language-plaintext highlighter-rouge">T_DATA</code>.</p>

<h2 id="typeddata">TypedData</h2>

<p>Until just a few months ago, <code class="language-plaintext highlighter-rouge">T_DATA</code> slots were fully used; here’s the <code class="language-plaintext highlighter-rouge">RTypedData</code> C struct in Ruby 3.4,
I added some annotations with the size of each field:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">RTypedData</span> <span class="p">{</span>
    <span class="cm">/** The part that all ruby objects have in common. */</span>
    <span class="k">struct</span> <span class="n">RBasic</span> <span class="n">basic</span><span class="p">;</span> <span class="c1">// 16B</span>

    <span class="cm">/**
     * This field  stores various  information about how  Ruby should  handle a
     * data.   This roughly  resembles a  Ruby level  class (apart  from method
     * definition etc.)
     */</span>
    <span class="k">const</span> <span class="n">rb_data_type_t</span> <span class="o">*</span><span class="k">const</span> <span class="n">type</span><span class="p">;</span> <span class="c1">// 8B</span>

    <span class="cm">/**
     * This has to be always 1.
     *
     * @internal
     */</span>
    <span class="k">const</span> <span class="n">VALUE</span> <span class="n">typed_flag</span><span class="p">;</span> <span class="c1">// 8B</span>

    <span class="cm">/** Pointer to the actual C level struct that you want to wrap. */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span> <span class="c1">// 8B</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Just quickly, the first <code class="language-plaintext highlighter-rouge">16B</code> was used for the common header all Ruby objects share, <code class="language-plaintext highlighter-rouge">8B</code> was used to store a pointer
to another struct that gives information to Ruby on what to do with this object, for instance, how to garbage collect it.</p>

<p>And then two other <code class="language-plaintext highlighter-rouge">8B</code> values, one pointing to arbitrary memory a C extension might have allocated, and then <code class="language-plaintext highlighter-rouge">typed_flag</code>.
If you read the comment associated with <code class="language-plaintext highlighter-rouge">typed_flag</code>, you may wonder what purpose it can possibly serve.</p>

<p>It’s there because <code class="language-plaintext highlighter-rouge">RTypedData</code> is the newer API for C extensions that was introduced in 2009 by Koichi Sasada.
Historically, when you needed to wrap a piece of native memory in a Ruby object, you’d use the <code class="language-plaintext highlighter-rouge">RData</code> API, and you had to
supply:</p>

<ul>
  <li>A pointer to the memory region.</li>
  <li>A marking function for the GC.</li>
  <li>A free function for the GC.</li>
</ul>

<p>That older, deprecated API is still there today, and you can see the struct that backs it up:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @deprecated
 *
 * Old  "untyped"  user  data.   It  has  roughly  the  same  usage  as  struct
 * ::RTypedData, but lacked several features such as support for compaction GC.
 * Use of this struct is not recommended  any longer.  If it is dead necessary,
 * please inform the core devs about your usage.
 *
 * @internal
 *
 * @shyouhei tried to add RBIMPL_ATTR_DEPRECATED for this type but that yielded
 * too many warnings  in the core.  Maybe  we want to retry  later...  Just add
 * deprecated document for now.
 */</span>
<span class="k">struct</span> <span class="n">RData</span> <span class="p">{</span>

    <span class="cm">/** Basic part, including flags and class. */</span>
    <span class="k">struct</span> <span class="n">RBasic</span> <span class="n">basic</span><span class="p">;</span>

    <span class="cm">/**
     * This function is called when the object is experiencing GC marks.  If it
     * contains references to  other Ruby objects, you need to  mark them also.
     * Otherwise GC will smash your data.
     *
     * @see      rb_gc_mark()
     * @warning  This  is  called  during  GC  runs.   Object  allocations  are
     *           impossible at that moment (that is why GC runs).
     */</span>
    <span class="n">RUBY_DATA_FUNC</span> <span class="n">dmark</span><span class="p">;</span>

    <span class="cm">/**
     * This function is called when the object  is no longer used.  You need to
     * do whatever necessary to avoid memory leaks.
     *
     * @warning  This  is  called  during  GC  runs.   Object  allocations  are
     *           impossible at that moment (that is why GC runs).
     */</span>
    <span class="n">RUBY_DATA_FUNC</span> <span class="n">dfree</span><span class="p">;</span>

    <span class="cm">/** Pointer to the actual C level struct that you want to wrap. */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>So in various places in the Ruby VM, when you interact with a <code class="language-plaintext highlighter-rouge">T_DATA</code> object, you need to know if it’s a <code class="language-plaintext highlighter-rouge">RTypedData</code> or a <code class="language-plaintext highlighter-rouge">RData</code>
before you can do much of anything with it.</p>

<p>That’s where <code class="language-plaintext highlighter-rouge">typed_flag</code> comes in. It’s at the same offset in the <code class="language-plaintext highlighter-rouge">RTypedData</code>struct as the <code class="language-plaintext highlighter-rouge">dfree</code> pointer in the <code class="language-plaintext highlighter-rouge">RData</code> struct, and for various reasons, it’s impossible for a legitimate C function pointer to be strictly equal to <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>That’s why <code class="language-plaintext highlighter-rouge">typed_flag</code> is always <code class="language-plaintext highlighter-rouge">1</code>, it allows us to check if a <code class="language-plaintext highlighter-rouge">T_DATA</code> is typed by checking <code class="language-plaintext highlighter-rouge">rdata-&gt;dfree == 1</code>.</p>

<p>Now you might wonder why I’m telling you all of this.
Well, it’s because that <code class="language-plaintext highlighter-rouge">typed_flag</code> field is using <code class="language-plaintext highlighter-rouge">8B</code> of space to store exactly <code class="language-plaintext highlighter-rouge">1bit</code> of information, and that has buggered me for several years.</p>

<p>Even though truth be told, the comment is outdated, and the field can also sometimes be <code class="language-plaintext highlighter-rouge">3</code> as <a href="https://railsatscale.com/2025-06-03-implementing-embedded-typeddata-objects/">we piggy-backed on it with Peter Zhu last year to implement embedded TypedData objects</a>.
But that’s still 32 times more than needed, so if someone could think of a better place to store these two bits, that would free and entire <code class="language-plaintext highlighter-rouge">8B</code> to store a direct reference to the <code class="language-plaintext highlighter-rouge">T_IMEMO/fields</code>.</p>

<h2 id="enter-set-man">Enter Set Man</h2>

<p>Well, it turns out that someone did earlier this year.</p>

<p>Just before the RubyKaigi developer meeting, Jeremy Evans <a href="https://bugs.ruby-lang.org/issues/21216">proposed to turn <code class="language-plaintext highlighter-rouge">Set</code> into a core class, and to reimplement it in C</a>, and that was accepted.
Later during the conference, he asked me to <a href="https://github.com/ruby/ruby/pull/13074">review his usage of the RTypedData API</a>, and I suggested a bunch of improvements to make <code class="language-plaintext highlighter-rouge">Set</code>
objects smaller and reduce pointer chasing by leveraging embedded RTypedData objects.</p>

<p>But turns out that there was a bit of an annoying tradeoff here. The <code class="language-plaintext highlighter-rouge">RTypedData</code> struct is <code class="language-plaintext highlighter-rouge">40B</code> large, but when used embedded, we recycle the <code class="language-plaintext highlighter-rouge">data</code> pointer, so it’s only <code class="language-plaintext highlighter-rouge">32B</code> large,
and the <code class="language-plaintext highlighter-rouge">set_table</code> struct Jememy needed to store is <code class="language-plaintext highlighter-rouge">56B</code>, for a total of <code class="language-plaintext highlighter-rouge">88B</code>, which is a particularly annoying number.</p>

<p>Not because of the meaning some distasteful people attribute to it, but because it is just <code class="language-plaintext highlighter-rouge">8B</code> too large to fit in a standard <code class="language-plaintext highlighter-rouge">80B</code> GC slot, hence if we marked it as embeded, the footprint would grow from <code class="language-plaintext highlighter-rouge">40 + 56 = 96B</code> to <code class="language-plaintext highlighter-rouge">160B</code> with lots of wasted space.</p>

<p>In all honesty, it wasn’t a massive problem unless your application is using a massive amount of sets, but it seems that it really bothered Jeremy.</p>

<p>What he came up with a couple of weeks later was that <a href="https://github.com/ruby/ruby/pull/13190">he moved these two bits of memory into the low bits of <code class="language-plaintext highlighter-rouge">RTypedData.type</code> and <code class="language-plaintext highlighter-rouge">RData.dmark</code></a>,
freeing <code class="language-plaintext highlighter-rouge">8B</code> per embedded TypedData object and allowing <code class="language-plaintext highlighter-rouge">Set</code> objects to fit in 80B.</p>

<p>Here again, the assumption was that because of alignment rules, the three lower bits of pointers can’t ever be set, so we can store our own information in there.</p>

<p>But now, I think <a href="https://github.com/ruby/ruby/pull/14134">this space could be put to better use to store a reference to a companion <code class="language-plaintext highlighter-rouge">T_IMEMO/fields</code></a>, so we could skip the global instance variables table.
The problem is that here again it’s a matter of tradeoff. We can waste some memory to save some CPU cycles, which is better is really just a judgment call.</p>

<p>Just like this issue bothered Jeremy a few months back, it now bothered me, and I went searching for a way to save another <code class="language-plaintext highlighter-rouge">8B</code> in <code class="language-plaintext highlighter-rouge">Set</code> objects.</p>

<h2 id="shrinking-set">Shrinking Set</h2>

<p>Hence, I started to stare at the <code class="language-plaintext highlighter-rouge">struct set_table</code> while frowning my eyebrows in the hope of spotting some redundant or superfluous member I could eliminate:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">set_table</span> <span class="p">{</span>
    <span class="cm">/* Cached features of the table -- see st.c for more details.  */</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">entry_power</span><span class="p">,</span> <span class="n">bin_power</span><span class="p">,</span> <span class="n">size_ind</span><span class="p">;</span>
    <span class="cm">/* How many times the table was rebuilt.  */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rebuilds_num</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">st_hash_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
    <span class="cm">/* Number of entries currently in the table.  */</span>
    <span class="n">st_index_t</span> <span class="n">num_entries</span><span class="p">;</span>
    <span class="cm">/* Array of bins used for access by keys.  */</span>
    <span class="n">st_index_t</span> <span class="o">*</span><span class="n">bins</span><span class="p">;</span>
    <span class="cm">/* Start and bound index of entries in array entries.
       entries_starts and entries_bound are in interval
       [0,allocated_entries].  */</span>
    <span class="n">st_index_t</span> <span class="n">entries_start</span><span class="p">,</span> <span class="n">entries_bound</span><span class="p">;</span>
    <span class="cm">/* Array of size 2^entry_power.  */</span>
    <span class="n">set_table_entry</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>I was first attracted to the trio of <code class="language-plaintext highlighter-rouge">num_entries</code>, <code class="language-plaintext highlighter-rouge">entries_start</code>, and <code class="language-plaintext highlighter-rouge">entries_bound</code>. All of these are <code class="language-plaintext highlighter-rouge">8B</code> integers, so if I could eliminate just one of them, I’d be set<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>.</p>

<p>Without being really intimate with the set implementation, I guessed that surely, if you know how many entries you have, you don’t need both the offset of the start and end of the entries list.
So in theory, I could just replace every reference to <code class="language-plaintext highlighter-rouge">entries_bound</code> by <code class="language-plaintext highlighter-rouge">entries_start + num_entries</code>.</p>

<p>What I do when I experiment with code I’m not fully familiar with, is that I try to prove my assumptions.
Here I wrote a small helper function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="n">st_index_t</span>
<span class="nf">set_entries_bound</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">set_table</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RUBY_ASSERT</span><span class="p">(</span><span class="n">set</span><span class="o">-&gt;</span><span class="n">entries_start</span> <span class="o">+</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">==</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">entries_bound</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">set</span><span class="o">-&gt;</span><span class="n">entries_bound</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And then went over the code to replace all the direct accesses to <code class="language-plaintext highlighter-rouge">set-&gt;entries_bound</code> by my helper, and tried to run the test suite to see if that <code class="language-plaintext highlighter-rouge">RUBY_ASSERT</code> would trip or not.</p>

<p>Well, turns out it wasn’t that simple… After seeing the test suite light up like a Christmas tree, I dug into the code
helped by the backtraces in the crash reports, and realized the <code class="language-plaintext highlighter-rouge">entries_bound</code> doesn’t always match the entries’ size,
There is even a comment about it in the code:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/* Do not update entries_bound here.  Otherwise, we can fill all
       bins by deleted entry value before rebuilding the table.  */</span>
</code></pre></div></div>

<p>So that was a bust, and I went back to the drawing board.</p>

<p>After some more staring and eyebrow frowning, I got another idea.</p>

<p>Ruby’s hash-tables (Ruby sets are hash-sets) are ordered.
Hence, you can see them as the combination of a regular unordered hash table and a classic array. The hash-table values are just offset into that array.</p>

<p>Here, the hash-table part is the <code class="language-plaintext highlighter-rouge">st_index_t *bins</code>, and the array part is <code class="language-plaintext highlighter-rouge">set_table_entry *entries</code>.</p>

<p>Both of these are memory regions allocated with <code class="language-plaintext highlighter-rouge">malloc</code>, and they are grown and shrunk at the same time when you add or remove elements from the set.</p>

<p>Hence, if we can know how large one of them is, we could allocate both with a single <code class="language-plaintext highlighter-rouge">malloc</code>, and then access the other by simply skipping over the first one.</p>

<p>In this case, the size of <code class="language-plaintext highlighter-rouge">set_table.bins</code> is indicated by <code class="language-plaintext highlighter-rouge">set_table.bin_power</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Return size of the allocated bins of table TAB.  */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">st_index_t</span>
<span class="nf">set_bins_size</span><span class="p">(</span><span class="k">const</span> <span class="n">set_table</span> <span class="o">*</span><span class="n">tab</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">features</span><span class="p">[</span><span class="n">tab</span><span class="o">-&gt;</span><span class="n">entry_power</span><span class="p">].</span><span class="n">bins_words</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">st_index_t</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">That</span><span class="err">'</span><span class="n">s</span> <span class="n">how</span> <span class="p">[</span><span class="n">with</span> <span class="n">a</span> <span class="n">relatively</span> <span class="n">small</span> <span class="n">patch</span><span class="p">,</span> <span class="n">I</span> <span class="n">was</span> <span class="n">able</span> <span class="n">to</span> <span class="n">save</span> <span class="mi">8</span><span class="n">B</span> <span class="n">from</span> <span class="err">`</span><span class="k">struct</span> <span class="n">set_table</span><span class="err">`</span><span class="p">](</span><span class="n">https</span><span class="o">:</span><span class="c1">//github.com/ruby/ruby/commit/9250ece276bae357a6ac42cb832c67bbfab0eb01),</span>
<span class="n">which</span> <span class="n">could</span> <span class="n">allow</span> <span class="n">us</span> <span class="n">to</span> <span class="n">keep</span> <span class="err">`</span><span class="n">Set</span><span class="err">`</span> <span class="n">objects</span> <span class="n">in</span> <span class="err">`</span><span class="mi">80</span><span class="n">B</span><span class="err">`</span> <span class="n">slots</span> <span class="n">even</span> <span class="k">if</span> <span class="n">we</span> <span class="n">make</span> <span class="n">embedded</span> <span class="err">`</span><span class="n">RTypedData</span><span class="err">`</span> <span class="err">`</span><span class="mi">32</span><span class="n">B</span><span class="err">`</span> <span class="n">again</span><span class="p">.</span>

<span class="n">However</span><span class="p">,</span> <span class="n">I</span> <span class="n">still</span> <span class="n">need</span> <span class="n">to</span> <span class="n">run</span> <span class="n">some</span> <span class="n">benchmarks</span> <span class="n">to</span> <span class="n">make</span> <span class="n">sure</span> <span class="n">this</span> <span class="n">patch</span> <span class="n">wouldn</span><span class="err">'</span><span class="n">t</span> <span class="n">degrade</span> <span class="n">set</span> <span class="n">performance</span> <span class="n">significantly</span><span class="p">.</span>

<span class="cp">## Lookup Cache
</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">remaining</span> <span class="n">types</span> <span class="n">like</span> <span class="err">`</span><span class="n">T_STRING</span><span class="err">`</span><span class="p">,</span> <span class="err">`</span><span class="n">T_ARRAY</span><span class="err">`</span><span class="p">,</span> <span class="n">or</span> <span class="err">`</span><span class="n">T_HASH</span><span class="err">`</span><span class="p">,</span> <span class="n">it</span><span class="err">'</span><span class="n">s</span> <span class="n">unlikely</span> <span class="n">we</span><span class="err">'</span><span class="n">ll</span> <span class="n">ever</span> <span class="n">find</span> <span class="n">spaces</span> <span class="n">in</span> <span class="n">their</span> <span class="n">slots</span> <span class="k">for</span> <span class="n">an</span> <span class="n">extra</span> <span class="n">reference</span><span class="p">.</span>
<span class="n">So</span> <span class="n">I</span> <span class="n">had</span> <span class="n">another</span> <span class="n">idea</span> <span class="n">to</span> <span class="n">speed</span> <span class="n">up</span> <span class="n">accesses</span> <span class="n">and</span> <span class="n">reduce</span> <span class="n">contention</span><span class="p">.</span>

<span class="n">The</span> <span class="n">core</span> <span class="n">of</span> <span class="n">the</span> <span class="n">assumption</span> <span class="n">is</span> <span class="n">that</span> <span class="n">whenever</span> <span class="n">we</span> <span class="n">look</span> <span class="n">up</span> <span class="n">the</span> <span class="n">instance</span> <span class="n">variables</span> <span class="n">of</span> <span class="n">an</span> <span class="n">object</span><span class="p">,</span> <span class="n">there</span> <span class="n">is</span> <span class="n">a</span> <span class="n">high</span> <span class="n">chance</span> <span class="n">that</span> <span class="n">the</span> <span class="n">next</span> <span class="n">lookup</span> <span class="n">will</span> <span class="n">be</span> <span class="k">for</span> <span class="n">the</span> <span class="n">same</span> <span class="n">object</span><span class="p">.</span>

<span class="n">So</span> <span class="n">what</span> <span class="k">if</span> <span class="n">we</span> <span class="n">kept</span> <span class="n">a</span> <span class="n">cache</span> <span class="n">of</span> <span class="n">the</span> <span class="n">last</span> <span class="n">object</span> <span class="n">we</span> <span class="n">looked</span> <span class="n">up</span><span class="p">,</span> <span class="n">and</span> <span class="n">its</span> <span class="n">associated</span> <span class="err">`</span><span class="n">T_IMEMO</span><span class="o">/</span><span class="n">fields</span><span class="err">`</span><span class="o">?</span>

<span class="n">In</span> <span class="n">pseudo</span><span class="o">-</span><span class="n">ruby</span><span class="o">:</span>

<span class="err">```</span><span class="n">ruby</span>
<span class="n">module</span> <span class="n">GenericIvarObject</span>
  <span class="n">GENERIC_FIELDS_TBL</span> <span class="o">=</span> <span class="n">Hash</span><span class="p">.</span><span class="n">new</span><span class="p">.</span><span class="n">compare_by_identity</span>

  <span class="n">def</span> <span class="n">instance_variable_get</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ivar_shape</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">shape</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
      <span class="n">fields_obj</span> <span class="o">=</span> <span class="k">if</span> <span class="n">Fiber</span><span class="p">[</span><span class="o">:</span><span class="n">__last_obj__</span><span class="p">]</span> <span class="o">==</span> <span class="n">self</span>
        <span class="n">Fiber</span><span class="p">[</span><span class="o">:</span><span class="n">__last_fields__</span><span class="p">]</span>
      <span class="k">else</span>
        <span class="n">Fiber</span><span class="p">[</span><span class="o">:</span><span class="n">__last_obj__</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span>
        <span class="n">Fiber</span><span class="p">[</span><span class="o">:</span><span class="n">__last_obj__</span><span class="p">]</span> <span class="o">=</span> <span class="n">RubyVM</span><span class="p">.</span><span class="n">synchronize</span> <span class="k">do</span>
          <span class="n">GENERIC_FIELDS_TBL</span><span class="p">[</span><span class="n">self</span><span class="p">]</span>
        <span class="n">end</span>
      <span class="n">end</span>

      <span class="n">fields_obj</span><span class="p">.</span><span class="n">instance_variable_get</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
    <span class="n">end</span>
  <span class="n">end</span>
<span class="n">end</span>
</code></pre></div></div>

<p>Given that the cache is in fiber local storage, we don’t need to protect it with a lock.</p>

<p>I have <a href="https://github.com/ruby/ruby/pull/14132">a draft patch for that idea</a> that I need to polish and benchmark, but I like that it’s quite simple.</p>

<h2 id="future-work">Future Work</h2>

<p>Ultimately, for the remaining cases, it would be good if the Ruby VM had a proper concurrent-map implementation to allow lock-free lookups into the generic instance variables table.
However, concurrent maps are <em>hard</em>, so it might not happen any time soon.</p>

<p>In the meantime, for the more important types like <code class="language-plaintext highlighter-rouge">T_STRUCT</code> and <code class="language-plaintext highlighter-rouge">T_DATA</code>, we now have solutions, either already merged or potentially soon to be, and for others, we have a way to reduce how often we look up the table.
And all that improves performance for both single-threaded and multi-ractor applications, so it’s a win-win.</p>

<p>My biggest concern with Ractors is that at some point we’d significantly impact single-threaded performance for the benefit of Ractors, so when we find optimizations that improve both use-cases, I’m particularly happy.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>You might think that since an object can’t be visible by more than one ractor unless it is frozen, then this isn’t a concern. But actually, since <code class="language-plaintext highlighter-rouge">object_id</code> is now essentially a memoized instance variable, it can happen. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>There was <a href="https://www.youtube.com/watch?v=wCOuJB6MEQo">a pretty good talk on that subject</a> at Euruko 2024. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Pun intended. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/ruby/performance/2025/08/11/unlocking-ractors-generic-variables.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">byroot&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">byroot&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://bsky.app/profile/byroot.bsky.social"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#bluesky"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://www.twitter.com/_byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_byroot</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Various ramblings.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
