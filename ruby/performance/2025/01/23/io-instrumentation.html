<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Instrumenting Rails Application | byroot’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Instrumenting Rails Application" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Recent Ruby releases added some nice tools to better instrument applications" />
<meta property="og:description" content="Recent Ruby releases added some nice tools to better instrument applications" />
<link rel="canonical" href="https://byroot.github.io/ruby/performance/2025/01/23/io-instrumentation.html" />
<meta property="og:url" content="https://byroot.github.io/ruby/performance/2025/01/23/io-instrumentation.html" />
<meta property="og:site_name" content="byroot’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-23T13:50:51+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Instrumenting Rails Application" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-01-23T13:50:51+00:00","datePublished":"2025-01-23T13:50:51+00:00","description":"Recent Ruby releases added some nice tools to better instrument applications","headline":"Instrumenting Rails Application","mainEntityOfPage":{"@type":"WebPage","@id":"https://byroot.github.io/ruby/performance/2025/01/23/io-instrumentation.html"},"url":"https://byroot.github.io/ruby/performance/2025/01/23/io-instrumentation.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png"><link type="application/atom+xml" rel="alternate" href="https://byroot.github.io/feed.xml" title="byroot&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">byroot&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Instrumenting Rails Application</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-01-23T13:50:51+00:00" itemprop="datePublished">Jan 23, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In <a href="https://byroot.github.io/ruby/performance/2025/01/23/the-mythical-io-bound-rails-app.html">my previous post about how IO-bound Rails applications really are</a>,
I pointed at a common pitfall, how CPU starvation can look like slow IOs.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">start</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="n">database_connection</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="s2">"SELECT ..."</span><span class="p">)</span>
<span class="n">query_duration</span> <span class="o">=</span> <span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1000.0</span>
<span class="nb">puts</span> <span class="s2">"Query took: </span><span class="si">#{</span><span class="n">query_duration</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">ms"</span>
</code></pre></div></div>

<p>In the above example, the instrumentation tells you how long it took for the database to answer your query, but may
also include the time needed for the Ruby thread to re-acquire the GVL, or perhaps the Ruby GC to run, or even the
operating system’s scheduler to resume the process.</p>

<p>Thankfully, in recent years Ruby added some new APIs that help measure these things.</p>

<h2 id="gctotal_time">GC.total_time</h2>

<p>Database queries and other IOs can often result in lots of allocations. For instance, if you select 100 database rows,
with a dozen columns each, you can probably expect a thousand or more allocations and any of these might trigger a GC
run inside the code block you are timing.</p>

<p>As such it can be a good idea to keep an eye on how much time Ruby is spending in GC. To help with that, <a href="https://bugs.ruby-lang.org/issues/10917#note-4">back in 2021
I resurrected an old feature request on the Ruby bug tracker</a> and
convinced <a href="https://github.com/ruby/ruby/pull/4757">Koichi Sadasa to implement the new <code class="language-plaintext highlighter-rouge">GC.total_time</code> API</a>.</p>

<p>This accessor is a monotonic counter, that represents the number of nanoseconds spent in the GC. So to tell how much
time a particular block of code spent in GC, you can do a simple subtraction:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">time_in_gc</span>
  <span class="n">before</span> <span class="o">=</span> <span class="no">GC</span><span class="p">.</span><span class="nf">total_time</span>
  <span class="k">yield</span>
  <span class="n">diff_ms</span> <span class="o">=</span> <span class="p">(</span><span class="no">GC</span><span class="p">.</span><span class="nf">total_time</span> <span class="o">-</span> <span class="n">before</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1_000_000.0</span>

  <span class="nb">puts</span> <span class="s2">"gc_time: </span><span class="si">#{</span><span class="n">diff_ms</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">ms"</span>
<span class="k">end</span>

<span class="n">time_in_gc</span> <span class="k">do</span>
  <span class="mi">2_000_000</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gc_time: 24.18ms
</code></pre></div></div>

<p>Now of course, if you are running a multi-threaded application, you can’t just subtract the time spent in GC from the
measured IO time, because another thread might be responsible for it. But it’s still a good idea to instrument it
and display it next to the IO duration.</p>

<p>That’s why starting from Rails 7.2, <a href="https://github.com/rails/rails/pull/51770">I added this measurement into Rails instrumentation API</a>.
Every <code class="language-plaintext highlighter-rouge">ActiveSupport::Notifications</code> event now has an associated <code class="language-plaintext highlighter-rouge">gc_time</code>, and Rails request logs include the overall time spent in GC.</p>

<h2 id="gvl-instrumentation-api">GVL Instrumentation API</h2>

<p>Even more common than GC, is GVL contention. If you configured your application to use too many threads, it can cause
long delays for a thread to resume after finishing some IOs.</p>

<p>That’s why <a href="https://bugs.ruby-lang.org/issues/18339">in Ruby 3.2 I added a new C API to allow instrumenting the GVL</a>.</p>

<p>This is quite a low-level API, and you need a C extension to integrate with it, but I wrote
[<code class="language-plaintext highlighter-rouge">gvltools</code>](https://github.com/Shopify/gvltools for that, and John Hawthorn wrote the
<a href="https://github.com/jhawthorn/gvl_timing"><code class="language-plaintext highlighter-rouge">gvl_timing</code> gem</a>, and there’s
also <a href="https://github.com/ivoanjo/gvl-tracing"><code class="language-plaintext highlighter-rouge">gvl-tracing</code></a> from Ivo Anjo.</p>

<p>Here’s how <code class="language-plaintext highlighter-rouge">gvltools</code> can be used to distinguish actual IO time from GVL wait time:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"bundler/inline"</span>

<span class="n">gemfile</span> <span class="k">do</span>
  <span class="n">gem</span> <span class="s2">"bigdecimal"</span> <span class="c1"># for trilogy</span>
  <span class="n">gem</span> <span class="s2">"trilogy"</span>
  <span class="n">gem</span> <span class="s2">"gvltools"</span>
<span class="k">end</span>

<span class="no">GVLTools</span><span class="o">::</span><span class="no">LocalTimer</span><span class="p">.</span><span class="nf">enable</span>

<span class="k">def</span> <span class="nf">measure_time</span>
  <span class="n">realtime_start</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">clock_gettime</span><span class="p">(</span><span class="no">Process</span><span class="o">::</span><span class="no">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="ss">:float_millisecond</span><span class="p">)</span>
  <span class="n">gvl_time_start</span> <span class="o">=</span> <span class="no">GVLTools</span><span class="o">::</span><span class="no">LocalTimer</span><span class="p">.</span><span class="nf">monotonic_time</span>
  <span class="k">yield</span>

  <span class="n">realtime</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">clock_gettime</span><span class="p">(</span><span class="no">Process</span><span class="o">::</span><span class="no">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="ss">:float_millisecond</span><span class="p">)</span> <span class="o">-</span> <span class="n">realtime_start</span>
  <span class="n">gvl_time</span> <span class="o">=</span> <span class="no">GVLTools</span><span class="o">::</span><span class="no">LocalTimer</span><span class="p">.</span><span class="nf">monotonic_time</span> <span class="o">-</span> <span class="n">gvl_time_start</span>
  <span class="n">gvl_time_ms</span> <span class="o">=</span> <span class="n">gvl_time</span> <span class="o">/</span> <span class="mf">1_000_000.0</span>
  <span class="n">io_time</span> <span class="o">=</span> <span class="n">realtime</span> <span class="o">-</span> <span class="n">gvl_time_ms</span>
  <span class="nb">puts</span> <span class="s2">"io: </span><span class="si">#{</span><span class="n">io_time</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">ms, gvl_wait: </span><span class="si">#{</span><span class="n">gvl_time_ms</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">ms"</span>
<span class="k">end</span>

<span class="n">trilogy</span> <span class="o">=</span> <span class="no">Trilogy</span><span class="p">.</span><span class="nf">new</span>

<span class="c1"># Measure a first time with just the main thread</span>
<span class="n">measure_time</span> <span class="k">do</span>
  <span class="n">trilogy</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"SELECT 1"</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span> <span class="n">n</span> <span class="p">)</span>
  <span class="k">return</span>  <span class="n">n</span>  <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1</span> <span class="p">).</span><span class="nf">include?</span> <span class="n">n</span>
  <span class="p">(</span> <span class="n">fibonacci</span><span class="p">(</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Spawn 5 CPU-heavy threads</span>
<span class="n">threads</span> <span class="o">=</span> <span class="mi">5</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="kp">loop</span> <span class="k">do</span>
      <span class="n">fibonacci</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Measure again with the background threads</span>
<span class="n">measure_time</span> <span class="k">do</span>
  <span class="n">trilogy</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="s2">"SELECT 1"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you run this example, you can see that on the first measurement, the GVL wait time is pretty much zero,
but on the second, it adds a massive half-a-second overhead:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>realtime: 0.22ms, gvl_wait: 0.0ms, io: 0.2ms
realtime: 549.29ms, gvl_wait: 549.22ms, io: 0.1ms
</code></pre></div></div>

<p>The downside of this API however, is that it adds some overhead to Ruby’s thread scheduler. I never really managed to
come up with a precise figure of how much overhead, perhaps it’s negligible, but until then, it’s a bit hard to justify
integrating it as a Rails default.</p>

<p>That being said, recently <a href="https://github.com/speedshop/gvl_metrics_middleware/tree/main">Yuki Nishijima from Speedshop open-sourced a middleware</a>
to hook this new instrumentation API into various APM services, so it might progressively see broader usage.</p>

<h2 id="operating-system-scheduler">Operating System Scheduler</h2>

<p>The one remaining thing that could cause IO operations to appear longer than they really are is the operating scheduler.
Unless you are running your application on dedicated hardware, and spawn no more than one Ruby process per core, then
it can happen that the operating system doesn’t immediately resume a process after it is done blocking on some IO.</p>

<p>I’m unfortunately not aware of a really good way to measure this.</p>

<p>The best I’ve found is <code class="language-plaintext highlighter-rouge">/proc/&lt;pid&gt;/schedstat</code> on Linux:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># cat /proc/1/schedstat</span>
40933713 1717706 178
</code></pre></div></div>

<p>The second number in that list is the amount of nanosecond the given process spent in the “runqueue”, in other words,
waiting to be assigned a CPU core so it can resume work.</p>

<p>But reading <code class="language-plaintext highlighter-rouge">/proc</code> around every IO would be a bit heavy-handed, so it’s not something I’ve ever integrated into an
application monitoring. Instead, we monitor it more globally on a per-machine basis as an indication that we’re running
too many processes in our containers.</p>


  </div><a class="u-url" href="/ruby/performance/2025/01/23/io-instrumentation.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">byroot&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">byroot&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://bsky.app/profile/byroot.bsky.social"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#bluesky"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://www.twitter.com/_byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_byroot</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Various ramblings.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
