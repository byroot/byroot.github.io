<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Unlocking Ractors: object_id | byroot’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Unlocking Ractors: object_id" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In a previous post about ractors, I explained why I think it’s really unlikely you’d ever be able to run an entire application inside a ractor, but that they could still be situationally very useful to move CPU-bound work out of the main thread, and to unlock some parallel algorithm." />
<meta property="og:description" content="In a previous post about ractors, I explained why I think it’s really unlikely you’d ever be able to run an entire application inside a ractor, but that they could still be situationally very useful to move CPU-bound work out of the main thread, and to unlock some parallel algorithm." />
<link rel="canonical" href="https://byroot.github.io/ruby/performance/2025/04/26/unlocking-ractors-object-id.html" />
<meta property="og:url" content="https://byroot.github.io/ruby/performance/2025/04/26/unlocking-ractors-object-id.html" />
<meta property="og:site_name" content="byroot’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-26T10:03:51+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Unlocking Ractors: object_id" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-04-26T10:03:51+00:00","datePublished":"2025-04-26T10:03:51+00:00","description":"In a previous post about ractors, I explained why I think it’s really unlikely you’d ever be able to run an entire application inside a ractor, but that they could still be situationally very useful to move CPU-bound work out of the main thread, and to unlock some parallel algorithm.","headline":"Unlocking Ractors: object_id","mainEntityOfPage":{"@type":"WebPage","@id":"https://byroot.github.io/ruby/performance/2025/04/26/unlocking-ractors-object-id.html"},"url":"https://byroot.github.io/ruby/performance/2025/04/26/unlocking-ractors-object-id.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png"><link type="application/atom+xml" rel="alternate" href="https://byroot.github.io/feed.xml" title="byroot&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">byroot&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Unlocking Ractors: object_id</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-04-26T10:03:51+00:00" itemprop="datePublished">Apr 26, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In <a href="/ruby/performance/2025/02/27/whats-the-deal-with-ractors.html">a previous post about ractors</a>, I explained why I think it’s really unlikely you’d ever be able to run an entire application inside a ractor, but that they could
still be situationally very useful to move CPU-bound work out of the main thread, and to unlock some parallel algorithm.</p>

<p>But as I mentioned, this is unfortunately not yet viable because there are many known implementation bugs that can lead
to interpreter crashes, and that while they are supposed to execute in parallel, the Ruby VM still has one true global
lock that Ractors need to acquire to perform certain operations, making them often perform worse than the equivalent
single-threaded code.</p>

<p>But things are evolving rapidly.
Since then, there is now a team of people working on fixing exactly that: tackling known bugs and eliminating or reducing the remaining contention points.</p>

<p>The one example I gave to illustrate this remaining contention, was the <code class="language-plaintext highlighter-rouge">fstring_table</code>, which in short is a big internal
hash table used to deduplicate strings, which Ruby does whenever you use a String as a key in a Hash.
Because looking into that table while another Ractor is inserting a new entry would result in a crash (or worse),
until last week Ruby had to acquire the remaining VM lock whenever it touched that table.</p>

<p>But <a href="https://bugs.ruby-lang.org/issues/21268">John Hawthorn recently replaced it with a lock-free Hash-Set</a>, and now this
contention point is gone. If you re-run the JSON benchmarks from the previous post using the latest Ruby master,
the Ractor version is now twice as fast as the single-threaded version, instead of being 3 times slower.</p>

<p>This still isn’t perfect though, as the benchmark uses 5 ractors, hence in an ideal world should be almost 5 times faster
then the single-threaded example, so we still have a lot of work to do to eliminate or reduce the remaining contention
points.</p>

<p>One of such remaining contention points, that you likely didn’t suspect would be one, is
<a href="https://docs.ruby-lang.org/en/3.4/Object.html#method-i-object_id">the <code class="language-plaintext highlighter-rouge">#object_id</code> method</a>.
And on my way back from RubyKaigi, I started working on tackling it.</p>

<p>But before we delve into what I plan to do about it, let’s talk about how this method came to be a contention point.</p>

<h2 id="a-little-bit-of-history">A Little Bit Of History</h2>

<p>Up until Ruby 2.6, the <code class="language-plaintext highlighter-rouge">#object_id</code> implementation used to be quite trivial:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span>
<span class="nf">rb_obj_id</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">STATIC_SYM_P</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SYM2ID</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RVALUE</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">FIXNUM_FLAG</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">FLONUM_P</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">LL2NUM</span><span class="p">((</span><span class="n">SIGNED_VALUE</span><span class="p">)</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SPECIAL_CONST_P</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">LONG2NUM</span><span class="p">((</span><span class="n">SIGNED_VALUE</span><span class="p">)</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">LL2NUM</span><span class="p">((</span><span class="n">SIGNED_VALUE</span><span class="p">)(</span><span class="n">obj</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Of course, it’s C so it might be a bit cryptic to the uninitiated, but in short, for the common case of a heap allocated
object, its <code class="language-plaintext highlighter-rouge">object_id</code> would be the address where the object is stored, divided by two.
So in a way, <code class="language-plaintext highlighter-rouge">#object_id</code> used to return you an actual pointer to the object.</p>

<p>This made implementing the lesser-known counterpart of <code class="language-plaintext highlighter-rouge">#object_id</code>, <a href="https://docs.ruby-lang.org/en/2.5.0/ObjectSpace.html#method-c-_id2ref"><code class="language-plaintext highlighter-rouge">ObjectSpace._id2ref</code></a>,
just as trivial, multiply the <code class="language-plaintext highlighter-rouge">object_id</code> by two, and here you go, you now have a pointer to the corresponding object.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="s2">"I am a string"</span>
<span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">_id2ref</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="nf">object_id</span><span class="p">).</span><span class="nf">equal?</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
</code></pre></div></div>

<p>But there was actually a major problem with that implementation, which is that the Ruby heap is composed of standard-size slots.
When an object is no longer referenced, the GC reclaims the object slot and will most likely re-use it for a future object.</p>

<p>Hence if you were to hold onto an <code class="language-plaintext highlighter-rouge">object_id</code>, and use <code class="language-plaintext highlighter-rouge">ObjectSpace._id2ref</code>, it’s not actually certain the object you get
back is the one you got the <code class="language-plaintext highlighter-rouge">object_id</code> from, it might be a totally different object.</p>

<p>It also meant that if you are holding onto an <code class="language-plaintext highlighter-rouge">object_id</code> as a way to know if you’ve already seen a given object,
you may run into some false positives.</p>

<p>That’s why <a href="https://bugs.ruby-lang.org/issues/15408">in 2018 there was already a feature request to deprecate both <code class="language-plaintext highlighter-rouge">#object_id</code> and <code class="language-plaintext highlighter-rouge">_id2ref</code></a>.
Back then Matz agreed to deprecated <code class="language-plaintext highlighter-rouge">_id2ref</code> for Ruby 2.7, but pointed out that removing <code class="language-plaintext highlighter-rouge">#object_id</code> would be too much of a breaking change,
and that it is a useful API.
However, this somehow fell through the cracks, and <code class="language-plaintext highlighter-rouge">_id2ref</code> was never formally deprecated, which is <a href="https://github.com/ruby/ruby/pull/13157">something I’d like to
do for Ruby 3.5</a>.</p>

<p>I’m not certain why <code class="language-plaintext highlighter-rouge">_id2ref</code> was added initially, given that <code class="language-plaintext highlighter-rouge">git blame</code> points to <a href="https://github.com/ruby/ruby/commit/210367ec889">a commit from 1999 that was generated by cvs2svn</a>.
But if I had to guess, I’d say it was added for <code class="language-plaintext highlighter-rouge">drb</code> which today remains the only significant user of that API in the stdlib, but <a href="https://github.com/ruby/drb/pull/35">even that is about to change</a>.</p>

<h2 id="gc-compaction">GC Compaction</h2>

<p>Regardless of why <code class="language-plaintext highlighter-rouge">_id2ref</code> was added, that major flaw in its design became a blocker for Aaron Patterson when <a href="https://bugs.ruby-lang.org/issues/15626">he implemented
GC compaction in Ruby 2.7</a>.
Since GC compaction implies that objects can be moved from one slot to another, <code class="language-plaintext highlighter-rouge">#object_id</code> could no longer be derived from
the object address, otherwise, it wouldn’t remain stable.</p>

<p>What Aaron did is conceptually simple:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Kernel</span>
  <span class="k">def</span> <span class="nf">object_id</span>
    <span class="k">unless</span> <span class="nb">id</span> <span class="o">=</span> <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">OBJ_TO_ID_TABLE</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span>
      <span class="nb">id</span> <span class="o">=</span> <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">next_obj_id</span>
      <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">next_obj_id</span> <span class="o">+=</span> <span class="mi">8</span>
      <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">OBJ_TO_ID_TABLE</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
      <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span>
    <span class="k">end</span>
    <span class="nb">id</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ObjectSpace</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">_id2ref</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In short, Ruby added two internal Hash tables. One of them with objects as keys and IDs as values, and the inverse for the other.
Whenever you access an object’s ID for the first time, a unique ID is created by incrementing an internal counter,
and the relation between the object and its ID is stored in the two hash tables.</p>

<p>As a Ruby user, you can observe this change easily by printing some <code class="language-plaintext highlighter-rouge">object_id</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">object_id</span>
<span class="nb">p</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">object_id</span>
</code></pre></div></div>

<p>Up to Ruby 2.6, the above code will print some large and seemingly random integers such as <code class="language-plaintext highlighter-rouge">50666405449360</code>, whereas on
Ruby 2.7 onwards, it will print small integers, likely <code class="language-plaintext highlighter-rouge">8</code> and <code class="language-plaintext highlighter-rouge">16</code>.</p>

<p>This change both solved the historical issue with <code class="language-plaintext highlighter-rouge">_id2ref</code> and allowed the GC to keep stable IDs when moving objects from one
address to the other, but made <code class="language-plaintext highlighter-rouge">object_id</code> way more costly than it used to be.</p>

<p>Ruby’s hash-table implementation stores 3 pointer-sized numbers per entry.
One for the key, one for the value, and one for the hashcode:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">st_table_entry</span> <span class="p">{</span>
    <span class="n">st_hash_t</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">st_data_t</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">st_data_t</span> <span class="n">record</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>And given every <code class="language-plaintext highlighter-rouge">object_id</code> is stored in two hash-tables, that makes for a total of <code class="language-plaintext highlighter-rouge">48B</code> (plus some change) per <code class="language-plaintext highlighter-rouge">object_id</code>.
That’s quite a lot of memory for just a small number.</p>

<p>In addition, accessing the <code class="language-plaintext highlighter-rouge">object_id</code> now requires doing a hash lookup, when before it was a simple division, and whenever
the GC frees or moves an object that has an ID, it needs to update these two hash-tables.</p>

<p>To be clear, I don’t have any evidence that these two tables cause significant memory or CPU overhead in real-world Ruby applications.
I’m just saying that <code class="language-plaintext highlighter-rouge">#object_id</code> is way more expensive than one might expect.</p>

<h2 id="entering-ractors">Entering Ractors</h2>

<p>Then later on, when Koichi Sasada implemented Ractors since now multiple ractors could attempt to access these two hash-tables
concurrently, <a href="https://github.com/ruby/ruby/commit/da3438a5045">he had to add a lock around them in <code class="language-plaintext highlighter-rouge">#object_id</code></a>, turning
<code class="language-plaintext highlighter-rouge">#object_id</code> in a contention point:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Kernel</span>
  <span class="k">def</span> <span class="nf">object_id</span>
    <span class="no">RubyVM</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="k">unless</span> <span class="nb">id</span> <span class="o">=</span> <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">OBJ_TO_ID_TABLE</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">next_obj_id</span>
        <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">next_obj_id</span> <span class="o">+=</span> <span class="mi">8</span>
        <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">OBJ_TO_ID_TABLE</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span>
      <span class="k">end</span>
      <span class="nb">id</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ObjectSpace</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">_id2ref</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="no">RubyVM</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>At this point, you may wonder if it’s really a big deal.
After all, <code class="language-plaintext highlighter-rouge">#object_id</code> is used a bit for debugging, but not so much in actual production code.
And this is mostly true, but it does come up in real-world code, e.g. <a href="https://github.com/mikel/mail/blob/d1d65b370b109b98e673a934e8b70a0c1f58cc59/lib/mail/message.rb#L1698">in the <code class="language-plaintext highlighter-rouge">mail</code> gem</a>,
<a href="https://github.com/rubocop/rubocop/blob/4a611564c4e1d8ec12a8e45e96490465e5141605/lib/rubocop/cop/variable_force/branch.rb#L129-L131">in <code class="language-plaintext highlighter-rouge">rubocop</code></a>,
and of course <a href="https://github.com/rails/rails/blob/99e27fa586af7db2b5334124a62eb3a464cdffd8/activesupport/lib/active_support/cache/strategy/local_cache.rb#L213-L215">quite a bit in Rails</a>.</p>

<p>But calling <code class="language-plaintext highlighter-rouge">Kernel#object_id</code> isn’t the only way you might rely on an object ID.</p>

<p>The <a href="https://docs.ruby-lang.org/en/3.4/Object.html#method-i-hash"><code class="language-plaintext highlighter-rouge">Object#hash</code></a> method for example rely on it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">st_index_t</span>
<span class="nf">objid_hash</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">VALUE</span> <span class="n">object_id</span> <span class="o">=</span> <span class="n">rb_obj_id</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FIXNUM_P</span><span class="p">(</span><span class="n">object_id</span><span class="p">))</span>
        <span class="n">object_id</span> <span class="o">=</span> <span class="n">rb_big_hash</span><span class="p">(</span><span class="n">object_id</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">st_index_t</span><span class="p">)</span><span class="n">st_index_hash</span><span class="p">((</span><span class="n">st_index_t</span><span class="p">)</span><span class="n">NUM2LL</span><span class="p">(</span><span class="n">object_id</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">VALUE</span>
<span class="nf">rb_obj_hash</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">hnum</span> <span class="o">=</span> <span class="n">any_hash</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">objid_hash</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ST2FIX</span><span class="p">(</span><span class="n">hnum</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Common value classes such as <code class="language-plaintext highlighter-rouge">String</code>, <code class="language-plaintext highlighter-rouge">Array</code> etc, do define their own <code class="language-plaintext highlighter-rouge">#hash</code> method that doesn’t rely on the object ID,
but all other objects that are compared by identity by default will end up using <code class="language-plaintext highlighter-rouge">Object#hash</code>, hence accessing the <code class="language-plaintext highlighter-rouge">object_id</code>.</p>

<p>For instance here’s a quite class <code class="language-plaintext highlighter-rouge">#hash</code> implementation from one of Rails classes:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#  activerecord/lib/arel/nodes/delete_statement.rb</span>
  <span class="k">def</span> <span class="nf">hash</span>
    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">,</span> <span class="vi">@relation</span><span class="p">,</span> <span class="vi">@wheres</span><span class="p">,</span> <span class="vi">@orders</span><span class="p">,</span> <span class="vi">@limit</span><span class="p">,</span> <span class="vi">@offset</span><span class="p">,</span> <span class="vi">@key</span><span class="p">].</span><span class="nf">hash</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>It absolutely isn’t obvious, but here we’re hashing a <code class="language-plaintext highlighter-rouge">Class</code> object, and classes are indexed by identity like a default object:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:hash</span><span class="p">).</span><span class="nf">owner</span>
<span class="o">=&gt;</span> <span class="no">Kernel</span>
<span class="o">&gt;&gt;</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:hash</span><span class="p">).</span><span class="nf">owner</span>
<span class="o">=&gt;</span> <span class="no">Kernel</span>
</code></pre></div></div>

<p>Hence the above code currently requires to lock the entire virtual machine, just to produce a hashcode.</p>

<h2 id="deoptimization">Deoptimization</h2>

<p>So what could we do to remove or reduce the need to synchronize the entire virtual machine when accessing object IDs?</p>

<p>Well first, given that <code class="language-plaintext highlighter-rouge">ObjectSpace._id2ref</code> is very rarely used, and will likely be marked as deprecated soon,
we can start by optimistically not creating nor updating the <code class="language-plaintext highlighter-rouge">id -&gt; object</code> table until someone needs it, which hopefully
won’t be the case in the vast majority of programs:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Kernel</span>
  <span class="k">def</span> <span class="nf">object_id</span>
    <span class="no">RubyVM</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="k">unless</span> <span class="nb">id</span> <span class="o">=</span> <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">OBJ_TO_ID_TABLE</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">next_obj_id</span>
        <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">next_obj_id</span> <span class="o">+=</span> <span class="mi">8</span>
        <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">OBJ_TO_ID_TABLE</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="k">if</span> <span class="k">defined?</span><span class="p">(</span><span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">)</span>
          <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span>
        <span class="k">end</span>
      <span class="k">end</span>
      <span class="nb">id</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ObjectSpace</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">_id2ref</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="no">RubyVM</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="k">unless</span> <span class="k">defined?</span><span class="p">(</span><span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">)</span>
        <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span> <span class="o">=</span> <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">OBJ_TO_ID_TABLE</span><span class="p">.</span><span class="nf">invert</span>
      <span class="k">end</span>
      <span class="no">ObjectSpace</span><span class="o">::</span><span class="no">ID_TO_OBJ_TABLE</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This doesn’t remove the lock yet, but assuming your program never calls <code class="language-plaintext highlighter-rouge">ObjectSpace._id2ref</code> it removes some work
from inside the lock, hence it shouldn’t be held as long.
And even if you don’t use Ractors, it should slightly reduce memory usage as well as remove work for the GC,
as demonstrated by a micro-benchmark:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>benchmark:
  baseline: "Object.new"
  object_id: "Object.new.object_id"
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>compare-ruby: ruby 3.5.0dev (2025-04-10T09:44:40Z master 684cfa42d7) +YJIT +PRISM [arm64-darwin24]
built-ruby: ruby 3.5.0dev (2025-04-10T10:13:43Z lazy-id-to-obj d3aa9626cc) +YJIT +PRISM [arm64-darwin24]
warming up..

|           |compare-ruby|built-ruby|
|:----------|-----------:|---------:|
|baseline   |     26.364M|   25.974M|
|           |       1.01x|         -|
|object_id  |     10.293M|   14.202M|
|           |           -|     1.38x|
</code></pre></div></div>

<p>As always, when possible, the most efficient way to speed up some code is to not call it if you can avoid it.</p>

<p>If you’re curious to see the actual implementation, <a href="https://github.com/ruby/ruby/pull/13115">you can have a look at the pull request</a>.</p>

<h2 id="inline-storage">Inline Storage</h2>

<p>But while saving a bit of memory and CPU is nice, we’re still not significantly reducing contention, so what else could we do?</p>

<p>The crux of the issue here is that the <code class="language-plaintext highlighter-rouge">object_id</code> is stored in a centralized hash table, and as long as it will be the case,
synchronization will be required, short of implementing a lock-free hash table, but this is quite tricky to do.
Much trickier than a hash-set John used for the <code class="language-plaintext highlighter-rouge">fstring_table</code>.</p>

<p>But more importantly, a centralized data structure to store all the IDs of all objects isn’t great for locality anyway.
More so, needing to do a hash lookup to access an object’s property is quite costly, when conceptually it should be stored directly
inside the object.</p>

<p>If you think about it, <code class="language-plaintext highlighter-rouge">object_id</code> isn’t very different from an instance variable:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Kernel</span>
  <span class="k">def</span> <span class="nf">object_id</span>
    <span class="vi">@__object_id</span> <span class="o">||=</span> <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">generate_next_obj_id</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>You’d need the id generation to be thread-safe, which is easily done using an atomic increment operation, but other than that,
assuming the object isn’t one of the special objects that is accessible from multiple ractors, you can mutate it to store the
<code class="language-plaintext highlighter-rouge">object_id</code> without having to lock the entire VM.</p>

<p>However, as is tradition, nothing is ever that simple.</p>

<h2 id="final-shapes">Final Shapes</h2>

<p>Since Ruby 3.2, objects use shapes to define how their instance variables are stored.</p>

<p>Here again, let’s use some pseudo-Ruby code to illustrate the basics of how they work.</p>

<p>To start, shapes are a tree-like structure. Every share has a parent (except the root one)
and 0-N children:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Shape</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">edge_name</span><span class="p">,</span> <span class="n">next_ivar_index</span><span class="p">)</span>
    <span class="vi">@parent</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="vi">@type</span> <span class="o">=</span> <span class="n">type</span>
    <span class="vi">@edge_name</span> <span class="o">=</span> <span class="n">edge_name</span>
    <span class="vi">@next_ivar_index</span> <span class="o">=</span> <span class="n">next_ivar_index</span>
    <span class="vi">@edges</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">add_ivar</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
    <span class="vi">@edges</span><span class="p">[</span><span class="n">ivar_name</span><span class="p">]</span> <span class="o">||=</span> <span class="no">Shape</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">:ivar</span><span class="p">,</span> <span class="n">ivar_name</span><span class="p">,</span> <span class="n">next_ivar_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>With this, when the Ruby VM has to execute code such as:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">role</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="vi">@role</span> <span class="o">=</span> <span class="n">role</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It can compute the object shape on the fly such as:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Allocate the object</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">new_object</span>
<span class="n">object</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="no">ROOT_SHAPE</span>

<span class="c1"># add @name</span>
<span class="n">next_shape</span> <span class="o">=</span> <span class="n">object</span><span class="p">.</span><span class="nf">add_ivar</span><span class="p">(</span><span class="ss">:@name</span><span class="p">)</span>
<span class="n">object</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="n">next_shape</span>
<span class="n">object</span><span class="p">.</span><span class="nf">ivars</span><span class="p">[</span><span class="n">next_shape</span><span class="p">.</span><span class="nf">next_ivar_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">name</span>

<span class="c1"># add @role</span>
<span class="n">next_shape</span> <span class="o">=</span> <span class="n">object</span><span class="p">.</span><span class="nf">add_ivar</span><span class="p">(</span><span class="ss">:@role</span><span class="p">)</span>
<span class="n">object</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="n">next_shape</span>
<span class="n">object</span><span class="p">.</span><span class="nf">ivars</span><span class="p">[</span><span class="n">next_shape</span><span class="p">.</span><span class="nf">next_ivar_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">role</span>
</code></pre></div></div>

<p>This method may seem surprising, but it’s actually very efficient for various reasons I won’t get into here,
because I wrote <a href="https://railsatscale.com/2023-10-24-memoization-pattern-and-object-shapes/">another post about it a bit over a year ago</a>,
go read it if you are curious to know more.</p>

<p>But how instance variables are laid out isn’t the only thing that shapes record. They also keep track of how large an object
is, hence how many instance variables it can store, as well as whether it has been frozen.</p>

<p>Still in pseudo-Ruby code, it looks like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Shape</span>
  <span class="k">def</span> <span class="nf">add_ivar</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="vi">@type</span> <span class="o">==</span> <span class="ss">:frozen</span>
      <span class="k">raise</span> <span class="s2">"Can't modify frozen object"</span>
    <span class="k">end</span>
    <span class="vi">@edges</span><span class="p">[</span><span class="n">ivar_name</span><span class="p">]</span> <span class="o">||=</span> <span class="no">Shape</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">:ivar</span><span class="p">,</span> <span class="n">ivar_name</span><span class="p">,</span> <span class="n">next_ivar_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">freeze</span>
    <span class="vi">@edges</span><span class="p">[</span><span class="ss">:__frozen</span><span class="p">]</span> <span class="o">||=</span> <span class="no">Shape</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">:frozen</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">next_ivar_index</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">frozen</code> shapes are final. It is expected that a shape of type <code class="language-plaintext highlighter-rouge">frozen</code> won’t ever have any children.</p>

<p>But in the case of <code class="language-plaintext highlighter-rouge">object_id</code>, we want to be able to store the id on any object, regardless of whether they are frozen
or not. So the first step is to modify shapes to allow that, <a href="https://github.com/Shopify/ruby/commit/ca92bbe4f646658f9a420e61089cf5d6e27a5a71">which I did in a relatively simple commit</a>.</p>

<p>But here too there was a bit of a complication. In a few cases, for instance when calling <code class="language-plaintext highlighter-rouge">Object#dup</code>, Ruby needs to find
the unfrozen version of a shape. Previously, since frozen shapes couldn’t possibly have children, it was quite simple:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nf">dup</span>
    <span class="n">new_object</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">allocate</span>
    <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:frozen</span>
      <span class="n">new_object</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span><span class="p">.</span><span class="nf">parent</span>
    <span class="k">else</span>
      <span class="n">new_object</span><span class="p">.</span><span class="nf">shape</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">shape</span>
    <span class="k">end</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Once you allow frozen shapes to have children, this operation becomes more involved, as you now need to go up the tree
to find the last non-frozen shape, then reapply all the child shapes you wish to carry over.</p>

<p>After this small refactoring was done, I could introduce a new type of shape: <code class="language-plaintext highlighter-rouge">SHAPE_OBJ_ID</code>, which behaves very similarly
to instance variable shapes:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Shape</span>
  <span class="k">def</span> <span class="nf">object_id</span>
    <span class="c1"># First check if there is an OBJ_ID shape in ancestors</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">self</span>
    <span class="k">while</span> <span class="n">shape</span><span class="p">.</span><span class="nf">parent</span>
      <span class="k">return</span> <span class="n">shape</span> <span class="k">if</span> <span class="n">shape</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="ss">:obj_id</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">.</span><span class="nf">parent</span>
    <span class="k">end</span>

    <span class="c1"># Otherwise create one.</span>
    <span class="vi">@edges</span><span class="p">[</span><span class="ss">:__object_id</span><span class="p">]</span> <span class="o">||=</span> <span class="no">Shape</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">:obj_id</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">next_ivar_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And just like this, we’re now able to reserve some inline space inside any object to store the <code class="language-plaintext highlighter-rouge">object_id</code>,
and in <em>some cases</em> we’re able to access an object’s ID fully lock-free.</p>

<h2 id="lock-free-shapes">Lock Free Shapes</h2>

<p>Why I’m saying <em>in some cases</em> is because there are still a number of limitations.</p>

<p>First, since shapes are mostly immutable, we can access an object’s shape, and all its ancestors without taking a lock.
However, finding or creating a shape’s child currently still requires synchronizing the VM.
So even if my patch was to be applied, Ruby would still lock when accessing an object’s ID for the very first time,
it would only be lock-free on subsequent accesses.</p>

<p>Being able to find or create child shapes in a lock-free way would be useful way beyond the <code class="language-plaintext highlighter-rouge">object_id</code> use case, so
hopefully we’ll get to it in the future, I haven’t yet dedicated much thought to it, but I’m hopeful we can find
a solution. But even if we can’t do it lock-free, I think we could at least use a dedicated lock for it, so we wouldn’t
contend with all the other code paths that synchronize the entire VM, only paths that do the same operation.</p>

<p>Then, if the object is potentially shared between ractors, we also still need to acquire the lock before storing the ID,
as otherwise, concurrent writes may cause a race condition. Given we need to both update the object’s shape and write
the <code class="language-plaintext highlighter-rouge">object_id</code> inside the object, we can’t do it all in an atomic manner.</p>

<p>Finally, not all objects store their instance variables in the same way.</p>

<h2 id="generic-instance-variables">Generic Instance Variables</h2>

<p>As a Rubyist, you likely know that in Ruby everything is an object, but that doesn’t mean all objects are equal.</p>

<p>In the context of instance variables, there are essentially three types of objects: <code class="language-plaintext highlighter-rouge">T_OBJECT</code>, <code class="language-plaintext highlighter-rouge">T_CLASS/T_MODULE</code> and
then all the rest.</p>

<p><code class="language-plaintext highlighter-rouge">T_OBJECT</code> are your classic objects that inherit from the <code class="language-plaintext highlighter-rouge">BasicObject</code> class. Their instance variables are stored
inline directly inside the object slot, as long as it’s large enough. If it ends up overflowing, then a separated memory
location is allocated, and instance variables are moved there, the object slot then only contains a pointer to that auxiliary memory.</p>

<p><code class="language-plaintext highlighter-rouge">T_CLASS</code> and <code class="language-plaintext highlighter-rouge">T_MODULE</code> as their name suggests are all instances of the <code class="language-plaintext highlighter-rouge">Class</code> and <code class="language-plaintext highlighter-rouge">Module</code> classes. These are much
larger than regular objects, as they need to keep track of a lot of things, such as their method table, a pointer to the
parent class, etc:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;</span> <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">memsize_of</span><span class="p">(</span><span class="no">Object</span><span class="p">.</span><span class="nf">new</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">40</span>
<span class="o">&gt;&gt;</span> <span class="no">ObjectSpace</span><span class="p">.</span><span class="nf">memsize_of</span><span class="p">(</span><span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">192</span>
</code></pre></div></div>

<p>As such, they never store their instance variables inline, they always store them in auxiliary memory, and they have
dedicated space in their object slot to store the auxiliary memory pointer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># internal/class.h
</span><span class="k">struct</span> <span class="n">rb_classext_struct</span> <span class="p">{</span>
    <span class="n">VALUE</span> <span class="o">*</span><span class="n">iv_ptr</span><span class="p">;</span> <span class="c1">// iv = instance variable</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, there are all the other objects, such as <code class="language-plaintext highlighter-rouge">T_STRING</code>, <code class="language-plaintext highlighter-rouge">T_ARRAY</code>, <code class="language-plaintext highlighter-rouge">T_HASH</code>, <code class="language-plaintext highlighter-rouge">T_REGEXP</code>, etc.
None of these have free space in their slot to store inline variables, and not even space to store the auxiliary memory
pointer.</p>

<p>So what does Ruby do when you do add an instance variable to such objects? Well, it stores it in a Hash-table of course!</p>

<p>In pseudo-Ruby, it would look like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">GenericIvarObject</span>
  <span class="k">class</span> <span class="nc">GenericStorage</span>
    <span class="nb">attr_accessor</span> <span class="ss">:shape</span>
    <span class="nb">attr_reader</span> <span class="ss">:ivars</span>

    <span class="k">def</span> <span class="nf">initialize</span>
      <span class="vi">@ivars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">instance_variable_get</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
    <span class="n">store</span> <span class="o">=</span> <span class="no">RubyVM</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="no">GENERIC_STORAGE</span><span class="p">[</span><span class="nb">self</span><span class="p">]</span> <span class="o">||=</span> <span class="no">GenericStorage</span><span class="p">.</span><span class="nf">new</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">ivar_shape</span> <span class="o">=</span> <span class="n">store</span><span class="p">.</span><span class="nf">shape</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">ivar_name</span><span class="p">)</span>
      <span class="n">store</span><span class="p">.</span><span class="nf">ivars</span><span class="p">[</span><span class="n">ivar_shape</span><span class="p">.</span><span class="nf">next_ivar_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>As you probably have noticed or even guessed, since this is yet another global hash table, any access needs to be synchronized,
which means that for objects other than <code class="language-plaintext highlighter-rouge">T_OBJECT</code>, <code class="language-plaintext highlighter-rouge">T_CLASS</code> and <code class="language-plaintext highlighter-rouge">T_MODULE</code>,
my patch replaces one global synchronized hash with another…</p>

<p>So perhaps for these, keeping the original <code class="language-plaintext highlighter-rouge">object -&gt; id</code> table would be preferable, that’s something I still need to figure out.</p>

<h3 id="conclusion">Conclusion</h3>

<p>My patch isn’t finished. I still have to figure out how to best deal with “generic” objects, and probably refine the
implementation some more, and perhaps it won’t even be merged at all in the end.</p>

<p>But I wanted to share it because explaining something helps me think about the problem,
and also because while I don’t think <code class="language-plaintext highlighter-rouge">object_id</code> is currently the biggest Ractor bottleneck,
it’s a good showcase of the type of work that needs to be done to make Ractors more parallel.</p>

<p>If you are curious about the patch, here’s <a href="https://github.com/ruby/ruby/compare/master...byroot:ruby:object_id-in-shape-snapshot">what it currently looks like as of this writing</a>.</p>

<p>Similar work will have to be done for other internal tables, such as the symbol table and the various method tables.</p>


  </div><a class="u-url" href="/ruby/performance/2025/04/26/unlocking-ractors-object-id.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">byroot&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">byroot&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://bsky.app/profile/byroot.bsky.social"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#bluesky"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://www.twitter.com/_byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_byroot</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Various ramblings.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
