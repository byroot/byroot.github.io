<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>There Isn’t Much Point to HTTP/2 Past The Load Balancer | byroot’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="There Isn’t Much Point to HTTP/2 Past The Load Balancer" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I want to write a post about Pitchfork, explaining where it comes from, why it is like it is, and how I see its future. But before I can get to that, I think I need to share my mental model on a few things, in this case, HTTP/2." />
<meta property="og:description" content="I want to write a post about Pitchfork, explaining where it comes from, why it is like it is, and how I see its future. But before I can get to that, I think I need to share my mental model on a few things, in this case, HTTP/2." />
<link rel="canonical" href="https://byroot.github.io/ruby/performance/2025/02/24/http2-past-the-load-balancer.html" />
<meta property="og:url" content="https://byroot.github.io/ruby/performance/2025/02/24/http2-past-the-load-balancer.html" />
<meta property="og:site_name" content="byroot’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-02-24T19:47:51+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="There Isn’t Much Point to HTTP/2 Past The Load Balancer" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-24T19:47:51+00:00","datePublished":"2025-02-24T19:47:51+00:00","description":"I want to write a post about Pitchfork, explaining where it comes from, why it is like it is, and how I see its future. But before I can get to that, I think I need to share my mental model on a few things, in this case, HTTP/2.","headline":"There Isn’t Much Point to HTTP/2 Past The Load Balancer","mainEntityOfPage":{"@type":"WebPage","@id":"https://byroot.github.io/ruby/performance/2025/02/24/http2-past-the-load-balancer.html"},"url":"https://byroot.github.io/ruby/performance/2025/02/24/http2-past-the-load-balancer.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
  <link rel="shortcut icon" type="image/png" href="/favicon.png"><link type="application/atom+xml" rel="alternate" href="https://byroot.github.io/feed.xml" title="byroot&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">byroot&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">There Isn&#39;t Much Point to HTTP/2 Past The Load Balancer</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-02-24T19:47:51+00:00" itemprop="datePublished">Feb 24, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I want to write a post about <a href="https://rubygems.org/gems/pitchfork">Pitchfork</a>, explaining where it comes from, why it
is like it is, and how I see its future.
But before I can get to that, I think I need to share my mental model on a few things, in this case, HTTP/2.</p>

<p>From time to time, either online or at conferences, I hear people complain about the lack of support for HTTP/2 in
Ruby HTTP servers, generally Puma.
And every time I do the same, I ask them why they want that feature, and so far nobody had an actual use case for it.</p>

<p>Personally, this lack of support doesn’t bother me much, because the only use case I can see for it, is wanting to expose
your Ruby HTTP directly to the internet without any sort of load balancer or reverse proxy, which I understand may seem
tempting, as it’s “one less moving piece”, but not really worth the trouble in my opinion.</p>

<p>If you are not familiar with the HTTP protocol and what’s different in version 2 (and even 3 nowadays), you might
be surprised by this take, so let me try to explain what it is all about.</p>

<h2 id="what-does-http2-solve">What Does HTTP/2 Solve?</h2>

<p>HTTP/2 started under the name SPDY in 2009, with multiple goals, but mainly to reduce page load latency, by allowing it to
download more resources faster.
A major factor in page load time is that a page isn’t just a single HTTP request.
Once your browser has downloaded the HTML page and starts parsing it, it will find other resources it needs to also
download to render the page, be it stylesheets, scripts, or images.</p>

<p>So a page isn’t one HTTP request, but a cascade of them, and in the late 2000s, the number of resources on the average
page kept going up.
This bloat was in part offset by broadband getting better, but still, HTTP/1.1 wasn’t really adequate to download
many small files quickly for a few reasons.</p>

<p>The first one is that <a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC 2616</a>, which introduced HTTP/1.1
specified that browsers were only allowed <em>two</em> concurrent connections to a given domain:</p>

<blockquote>
  <p>8.1.4 Practical Considerations</p>

  <p>Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a
given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy.</p>
</blockquote>

<p>So if you can only request a single resource per connection, and are limited to two connections, even if you have a very
large bandwidth, the latency to the server will have a massive impact on performance whenever you need to download more than
a couple of resources.</p>

<p>Imagine you have an excellent 100Gb connection, but are trying to load a webpage hosted across the Atlantic ocean.
The roundtrip time to that server (your ping), will probably be around 60ms. If you need to download 100 small resources
through just two connections, it will take at least <code class="language-plaintext highlighter-rouge">ping * (resources / connections)</code>, so 3 seconds, which isn’t great.</p>

<p>That’s what made many frontend optimization techniques like assets bundling absolutely essentials back then, they
made a major difference in load time<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.
Similarly, some websites were using a technique called domain sharding, splitting assets into multiple domains to allow
more concurrency.</p>

<p>In theory, even these two connections could have been used much more effectively by pipelining requests,
the RFC 2616 has an entire section about it, and that was one of the big features added in HTTP/1.1 compared to 1.0.
The idea is simple, after sending your request, you don’t have to wait for the response before sending more requests.
You can send 10 requests immediately before having received a single response, and the server will send them one by one
in order.</p>

<p>But in practice most browsers ended up disabling that feature by default because they ran into misbehaving servers, dooming
the feature.
It also wasn’t perfect, as you could experience <em>head-of-line blocking</em>.
Since responses don’t have an identifier to map them to the request they’re the answer to, they have to be sent in order.
If one resource is slow to generate, all the subsequent resources can’t be sent yet.</p>

<p>That’s why as early as 2008, browsers stopped respecting the two concurrent connection rule.
Firefox 3 started raising the connection limit to 6 per domain, and most other browsers followed suit shortly after.</p>

<p>However, more concurrent connections isn’t an ideal solution, because TCP connections have a <em>slow start</em>.
When you connect to a remote address, your computer doesn’t know if the link to that other machine can support 10 gbit/s
or only 56 kbit/s.
Hence, to avoid flooding the network with tons of packets that will be dropped on the floor, it starts relatively slow
and periodically increase the throughput until it receives packet loss notifications, at that point it know it has more
or less reached the maximum throuhput the link can sustain.</p>

<p>That’s why persistent connections are a big deal, a freshly established connection has a much lower throughput than one
that has seen some use.</p>

<p>So by multiplying the number of connections, you can download more resources faster, but it would be preferable if they
were all downloaded from the same connection to not suffer as much from TCP slow start.</p>

<p>And that’s exactly the main thing HTTP/2 solved, by allowing multiplexing of requests inside a single TCP connection,
solving the head-of-line blocking issue<sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p>

<p>It also did a few other things, such as mandating the use of encryption<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup> and also compressing request and response headers
with GZip, and “server push”, but multiplexing is really the big one.</p>

<h2 id="why-it-doesnt-matter-over-lan">Why It Doesn’t Matter Over LAN</h2>

<p>So the main motivation for HTTP/2 is multiplexing, and over the Internet, especially mobile Internet with somewhat more
spotty connections, it can have a massive impact.</p>

<p>But in the data center, not so much. If you think about it, the very big factor in the computation we did above was the
roundtrip time (ping) with the client.
Unless your infrastructure is terribly designed, that roundtrip time between your server (say Puma) and its client
(your load balancer or reverse proxy) should be extremely small, way under one millisecond, and totally dwarfed by the
actual request render time.</p>

<p>When you are serving mostly static assets over the Internet, latency may be high and HTTP/2 multiplexing is a huge deal.
But when you are serving application-generated responses over LAN (or even a UNIX socket), it won’t make a measurable
difference.</p>

<p>In addition to the low roundtrip time, the connections between your load balancer and application server likely have
a very long lifetime, hence don’t suffer from TCP slow start as much, and that’s assuming your operating system hasn’t
been tuned to disable slow start entirely, which is very common on servers.</p>

<h2 id="server-push-fail">Server Push Fail</h2>

<p>Another reason people may have wanted HTTP/2 all the way to the Ruby application server at one point was the “server push”
capability.</p>

<p>The idea was relatively simple, servers were allowed to send HTTP resources to the client without being prompted for it.
This way, when you request the landing page of a website, the server can send you all the associated resources up front
so your browser doesn’t have to parse the HTML to realize it needs them and start to ask for it.</p>

<p>However, that capability was actually removed from the spec and nowadays all browsers have removed it because was
actually doing more harm than good. It turns out that if the browser already had these resources in its cache, then
pushing them again would slow down the page load time.</p>

<p>People tried to find smart heuristics to know which resources may be in the cache or not, but in the end, none worked
and the feature was abandoned.</p>

<p>Today it has been superseded by <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103">103 Early Hints</a>, which
is a much simpler and elegant spec, and is retro-compatible with HTTP/1.1.</p>

<p>So there isn’t any semantic difference left between HTTP/1.1 and HTTP/2.
From a <a href="https://github.com/rack/rack/blob/main/SPEC.rdoc"><code class="language-plaintext highlighter-rouge">Rack</code></a> application point of view, whether the request was
issued through an HTTP/2 or HTTP/1.1 connection makes no difference.
You can tunnel one into the other just fine.</p>

<h2 id="extra-complexity">Extra Complexity</h2>

<p>In addition to not providing much if any benefit over LAN, HTTP/2 adds some extra complexity.</p>

<p>First, the complexity of implementation, as HTTP/2 while not being crazy complicated at all, is still a largely binary
protocol, so it’s much harder to debug.</p>

<p><del>But also the complexity of deployment. HTTP/2 is fully encrypted, so you need all your application servers to have a key and
certificate, that’s not insurmountable, but is an extra hassle compared to just using HTTP/1.1, unless of course for some
reasons you are required to use only encrypted connections even over LAN.</del> Edit: The HTTP/2 spec doesn’t actually require
encryption, so you can do unencrypted HTTP/2 inside your datacenter.</p>

<p>So unless you are deploying to a single machine, hence don’t have a load balancer, bringing HTTP/2 all the way to
the Ruby app server is significantly complexifying your infrastructure for little benefit.</p>

<p>And even if you are on a single machine, it’s probably to leave that concern to a reverse proxy, which will also take
care of serving static assets, normalize inbound requests, and also probably fend off at least some malicious actors.</p>

<p>There are numerous battle-tested reverse proxies such as Nginx, Caddy, etc, and they’re pretty simple to setup,
might as well use these common middlewares rather than to try to do everything in a single Ruby application.</p>

<p>But if you think a reverse proxy is too much complexity and you’d rather do without, there are now zero config solutions
such as <a href="https://github.com/basecamp/thruster">thruster</a>, I haven’t tried it so I can’t vouch for it, but at least on
paper it solves that need.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I think HTTP/2 is better thought of not as an upgrade over HTTP/1.1, but as an alternative protocol to more efficiently
transport the same HTTP resources over the Internet. In a way, it’s similar to how HTTPS doesn’t change the semantics
of the HTTP protocol, it only changes how it’s serialized over the wire.</p>

<p>So I believe handling HTTP/2 is better left to your infrastructure entry point, typically the load balancer or reverse proxy, for the same
reason that TLS has been left to the load balancer or reverse proxy for ages. They have to decrypt and decompress
the request to know what to do with it, why re-encrypt and re-compress it to forward it to the app server?</p>

<p>Hence, in my opinion, HTTP/2 support in Ruby HTTP servers isn’t a critically important feature, would be nice to have it for a few
niche use cases, but overall, the lack of it isn’t hindering much of anything.</p>

<p>Note that I haven’t mentioned HTTP/3, but while the protocol is very different, its goals are largely the same as HTTP2, so I’d apply the same conclusion to it.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Minifying and bundling still improve load time with HTTP/2, fewer requests and fewer bytes transferred are still positive, so they’re still useful, but it’s no longer critical to achieve a decent experience. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>At the HTTP layer at least, HTTP/2 still suffers from some forms of head-of-line blocking in lower layers, but it is beyond the scope of this post. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>The RFC doesn’t actually requires encryption, but all browser implementations do. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/ruby/performance/2025/02/24/http2-past-the-load-balancer.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">byroot&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">byroot&#39;s blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://bsky.app/profile/byroot.bsky.social"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#bluesky"></use></svg> <span class="username">byroot</span></a></li><li><a href="https://www.twitter.com/_byroot"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">_byroot</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Various ramblings.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
